# Trabajando con conceptos avanzados de Stream Pipeline 
Ya casi has llegado al final del aprendizaje sobre streams. Solo nos quedan unos pocos temas más. Verás la relación entre los streams y los datos subyacentes, el encadenamiento de objetos `Optional` y los *collectors* para agrupación.

---

## ENLAZANDO STREAMS CON LOS DATOS SUBYACENTES

¿Qué crees que imprime el siguiente código?

```java
25: var cats = new ArrayList<String>();
26: cats.add("Annie");
27: cats.add("Ripley");
28: var stream = cats.stream();
29: cats.add("KC");
30: System.out.println(stream.count());
```

La respuesta correcta es **3**. Las líneas 25–27 crean una `List` con dos elementos.  
La línea 28 solicita que se cree un *stream* a partir de esa `List`. Recuerda que los streams se evalúan de manera **perezosa** (*lazy evaluation*). Esto significa que el *stream* en realidad no se construye en la línea 28. En su lugar, se crea un objeto que sabe dónde buscar los datos cuando sea necesario. En la línea 29, la `List` obtiene un nuevo elemento. En la línea 30, el *stream pipeline* se ejecuta realmente. El *pipeline* se ejecuta primero, observa la fuente y ve tres elementos.

---

## ENCADENANDO `OPTIONAL`

A estas alturas, ya estás familiarizado con las ventajas de encadenar operaciones en un *stream pipeline*. Algunas de las operaciones intermedias para *streams* también están disponibles para `Optional`.

Supongamos que se te da un `Optional<Integer>` y te piden imprimir el valor, pero solo si es un número de tres dígitos. Sin programación funcional, podrías escribir lo siguiente:

```java
private static void threeDigit(Optional<Integer> optional) {
    if (optional.isPresent()) { // if externo
        var num = optional.get();
        var string = "" + num;
        if (string.length() == 3) // if interno
            System.out.println(string);
    }
}
```

Funciona, pero contiene sentencias `if` anidadas, lo que agrega complejidad innecesaria.  
Intentémoslo de nuevo con programación funcional:

```java
private static void threeDigit(Optional<Integer> optional) {
    optional.map(n -> "" + n)               // parte 1
            .filter(s -> s.length() == 3)   // parte 2
            .ifPresent(System.out::println); // parte 3
}
```

Este código es mucho más corto y expresivo. En los *lambdas*, el examen suele dividir una sola sentencia e identificar las partes con un comentario. Hemos hecho eso aquí para mostrar lo que ocurre tanto en el enfoque de programación funcional como en el de programación no funcional.

Supón ahora que se recibe un `Optional` vacío. El primer enfoque retorna `false` en el `if` externo. El segundo enfoque ve un `Optional` vacío y tanto `map()` como `filter()` simplemente lo dejan pasar. Entonces `ifPresent()` detecta que es un `Optional` vacío y no llama al parámetro de tipo `Consumer`.

El siguiente caso es cuando se nos da un `Optional.of(4)`. El primer enfoque retorna `false` en el `if` interno. El segundo enfoque asigna el número `4` a la cadena `"4"`. Luego, `filter()` retorna un `Optional` vacío, ya que el *filtro* no coincide, y `ifPresent()` no llama al `Consumer` correspondiente.

El caso final es cuando se nos da un `Optional.of(123)`. El primer enfoque retorna `true` para ambas sentencias `if`. El segundo enfoque asigna el número `123` a la cadena `"123"`. Luego, `filter()` retorna el mismo `Optional`, y `ifPresent()` finalmente sí llama al `Consumer`.

Ahora supongamos que queremos obtener un `Optional<Integer>` que represente la longitud de la cadena (`String`) contenida en otro `Optional`. Es fácil:

```java
Optional<Integer> result = optional.map(String::length);
```

¿Y si tuviéramos un método auxiliar que hiciera la lógica de calcular algo para nosotros y que retornara un `Optional<Integer>`? Usar `map` no funcionaría:

```java
Optional<Integer> result = optional
    .map(ChainingOptionals::calculator); // NO COMPILA
```

El problema es que `calculator` devuelve un `Optional<Integer>`. El método `map()` añadiría otro `Optional`, dándonos un  
`Optional<Optional<Integer>>`. Eso no nos sirve. La solución es llamar a `flatMap()` en su lugar:

```java
Optional<Integer> result = optional
    .flatMap(ChainingOptionals::calculator);
```

Esto sí funciona porque `flatMap` elimina la capa innecesaria. En otras palabras, **aplana** el resultado. Encadenar llamadas a `flatMap()` es útil cuando quieres transformar un tipo `Optional` en otro.
