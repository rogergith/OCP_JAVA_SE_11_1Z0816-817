# Trabajando con conceptos avanzados de Stream Pipeline 
Ya casi has llegado al final del aprendizaje sobre streams. Solo nos quedan unos pocos temas más. Verás la relación entre los streams y los datos subyacentes, el encadenamiento de objetos `Optional` y los *collectors* para agrupación.

---

## ENLAZANDO STREAMS CON LOS DATOS SUBYACENTES

¿Qué crees que imprime el siguiente código?

```java
25: var cats = new ArrayList<String>();
26: cats.add("Annie");
27: cats.add("Ripley");
28: var stream = cats.stream();
29: cats.add("KC");
30: System.out.println(stream.count());
```

La respuesta correcta es **3**. Las líneas 25–27 crean una `List` con dos elementos.  
La línea 28 solicita que se cree un *stream* a partir de esa `List`. Recuerda que los streams se evalúan de manera **perezosa** (*lazy evaluation*). Esto significa que el *stream* en realidad no se construye en la línea 28. En su lugar, se crea un objeto que sabe dónde buscar los datos cuando sea necesario. En la línea 29, la `List` obtiene un nuevo elemento. En la línea 30, el *stream pipeline* se ejecuta realmente. El *pipeline* se ejecuta primero, observa la fuente y ve tres elementos.

---

## ENCADENANDO `OPTIONAL`

A estas alturas, ya estás familiarizado con las ventajas de encadenar operaciones en un *stream pipeline*. Algunas de las operaciones intermedias para *streams* también están disponibles para `Optional`.

Supongamos que se te da un `Optional<Integer>` y te piden imprimir el valor, pero solo si es un número de tres dígitos. Sin programación funcional, podrías escribir lo siguiente:

```java
private static void threeDigit(Optional<Integer> optional) {
    if (optional.isPresent()) { // if externo
        var num = optional.get();
        var string = "" + num;
        if (string.length() == 3) // if interno
            System.out.println(string);
    }
}
```

Funciona, pero contiene sentencias `if` anidadas, lo que agrega complejidad innecesaria.  
Intentémoslo de nuevo con programación funcional:

```java
private static void threeDigit(Optional<Integer> optional) {
    optional.map(n -> "" + n)               // parte 1
            .filter(s -> s.length() == 3)   // parte 2
            .ifPresent(System.out::println); // parte 3
}
```

Este código es mucho más corto y expresivo. En los *lambdas*, el examen suele dividir una sola sentencia e identificar las partes con un comentario. Hemos hecho eso aquí para mostrar lo que ocurre tanto en el enfoque de programación funcional como en el de programación no funcional.

Supón ahora que se recibe un `Optional` vacío. El primer enfoque retorna `false` en el `if` externo. El segundo enfoque ve un `Optional` vacío y tanto `map()` como `filter()` simplemente lo dejan pasar. Entonces `ifPresent()` detecta que es un `Optional` vacío y no llama al parámetro de tipo `Consumer`.

El siguiente caso es cuando se nos da un `Optional.of(4)`. El primer enfoque retorna `false` en el `if` interno. El segundo enfoque asigna el número `4` a la cadena `"4"`. Luego, `filter()` retorna un `Optional` vacío, ya que el *filtro* no coincide, y `ifPresent()` no llama al `Consumer` correspondiente.

El caso final es cuando se nos da un `Optional.of(123)`. El primer enfoque retorna `true` para ambas sentencias `if`. El segundo enfoque asigna el número `123` a la cadena `"123"`. Luego, `filter()` retorna el mismo `Optional`, y `ifPresent()` finalmente sí llama al `Consumer`.

Ahora supongamos que queremos obtener un `Optional<Integer>` que represente la longitud de la cadena (`String`) contenida en otro `Optional`. Es fácil:

```java
Optional<Integer> result = optional.map(String::length);
```

¿Y si tuviéramos un método auxiliar que hiciera la lógica de calcular algo para nosotros y que retornara un `Optional<Integer>`? Usar `map` no funcionaría:

```java
Optional<Integer> result = optional
    .map(ChainingOptionals::calculator); // NO COMPILA
```

El problema es que `calculator` devuelve un `Optional<Integer>`. El método `map()` añadiría otro `Optional`, dándonos un  
`Optional<Optional<Integer>>`. Eso no nos sirve. La solución es llamar a `flatMap()` en su lugar:

```java
Optional<Integer> result = optional
    .flatMap(ChainingOptionals::calculator);
```

Esto sí funciona porque `flatMap` elimina la capa innecesaria. En otras palabras, **aplana** el resultado. Encadenar llamadas a `flatMap()` es útil cuando quieres transformar un tipo `Optional` en otro.


**EXCEPCIONES COMPROBADAS Y INTERFACES FUNCIONALES**

> Puede que ya hayas notado que la mayoría de las interfaces funcionales no declaran excepciones comprobadas (*checked exceptions*). Normalmente, esto está bien. Sin embargo, es un problema cuando se trabaja con métodos que declaran excepciones comprobadas. Supongamos que tenemos una clase con un método que lanza una excepción comprobada.

```java
import java.io.*;
import java.util.*;

public class ExceptionCaseStudy {
    private static List<String> create() throws IOException {
        throw new IOException();
    }
}
```

> Ahora lo usamos en un stream.

```java
public void good() throws IOException {
    ExceptionCaseStudy.create().stream().count();
}
```

> Nada nuevo aquí. El método `create()` lanza una excepción comprobada. El método que lo llama la maneja o la declara. ¿Y qué pasa con este?

```java
public void bad() throws IOException {
    Supplier<List<String>> s = ExceptionCaseStudy::create; // NO COMPILA
}
```

> El error real del compilador es el siguiente:

```
unhandled exception type IOException
```

> ¿Qué pasó? El problema es que la lambda a la que se expande esta referencia de método no declara una excepción. La interfaz `Supplier` no permite excepciones comprobadas. Hay dos enfoques para resolver este problema. Uno es capturar la excepción y convertirla en una excepción no comprobada.

```java
public void ugly() {
    Supplier<List<String>> s = () -> {
        try {
            return ExceptionCaseStudy.create();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    };
}
```

> Esto funciona. Pero el código es feo. Uno de los beneficios de la programación funcional es que el código debe ser fácil de leer y conciso. Otra alternativa es crear un método envolvente (*wrapper*) con el bloque `try/catch`.

```java
private static List<String> createSafe() {
    try {
        return ExceptionCaseStudy.create();
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
```

> Ahora podemos usar el envolvente seguro en nuestro `Supplier` sin problemas.

```java
public void wrapped() {
    Supplier<List<String>> s2 = ExceptionCaseStudy::createSafe;
}
```

---

**COLECCIONANDO RESULTADOS**

Casi has terminado de aprender sobre streams. El último tema se basa en lo que has aprendido hasta ahora para agrupar los resultados. Al inicio del capítulo, viste la operación terminal `collect()`. Hay muchos *collectors* predefinidos, incluyendo los mostrados en la Tabla 15.13. Estos *collectors* están disponibles a través de métodos estáticos en la interfaz `Collectors`. Veremos los diferentes tipos de *collectors* en las siguientes secciones.

### TABLA 15.13 Ejemplos de *collectors* de agrupación/partición

| **Collector**               | **Descripción**                                                                                                                        | **Valor de retorno cuando se pasa al `collect`** |
|-----------------------------|----------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------|
| `averagingDouble(ToDoubleFunction f)` | Calcula el promedio para nuestros tres tipos primitivos principales.                                                            | `Double`                                           |
| `averagingInt(ToIntFunction f)`        |                                                                                                                                        |                                                    |
| `averagingLong(ToLongFunction f)`      |                                                                                                                                        |                                                    |
| `counting()`                        | Cuenta el número de elementos.                                                                                                         | `Long`                                             |
| `groupingBy(Function f)`             | Crea un mapa agrupando por la función especificada con un posible proveedor de tipo de mapa y un posible *collector* descendente.     | `Map<K, List<T>>`                                  |
| `groupingBy(Function f, Collector dc)`|                                                                                                                                         |                                                    |
| `groupingBy(Function f, Supplier s, Collector dc)` |                                                                                                                               |                                                    |
| `joining(CharSequence cs)`           | Crea una sola cadena usando `cs` como delimitador entre elementos si se especifica uno.                                               | `String`                                           |
| `maxBy(Comparator c)`                | Encuentra el elemento más grande.                                                                                                       | `Optional<T>`                                      |
| `minBy(Comparator c)`                | Encuentra el elemento más pequeño.                                                                                                      | `Optional<T>`                                      |
| `mapping(Function f, Collector dc)`   | Agrega otro nivel de *collectors*.                                                                                                    | `Collector`                                        |
| `partitioningBy(Predicate p)`         | Crea un mapa agrupando por el predicado especificado con un posible *collector* descendente adicional.                                | `Map<Boolean, List<T>>`                            |
| `partitioningBy(Predicate p, Collector dc)` |                                                                                                                                         |                                                    |
| `summarizingDouble(ToDoubleFunction f)` | Calcula promedio, mínimo, máximo, etc.                                                                                               | `DoubleSummaryStatistics`                          |
| `summarizingInt(ToIntFunction f)`        |                                                                                                                                         | `IntSummaryStatistics`                             |
| `summarizingLong(ToLongFunction f)`      |                                                                                                                                         | `LongSummaryStatistics`                            |
| `summingDouble(ToDoubleFunction f)`      | Calcula la suma para nuestros tres tipos primitivos principales.                                                                     | `Double`                                           |
| `summingInt(ToIntFunction f)`            |                                                                                                                                         | `Integer`                                          |
| `summingLong(ToLongFunction f)`          |                                                                                                                                         | `Long`                                             |
| `toList()`                               | Crea una lista de tipo arbitrario.                                                                                                    | `List`                                             |
| `toSet()`                                | Crea un conjunto (*set*) de tipo arbitrario.                                                                                          | `Set`                                              |
| `toCollection(Supplier s)`               | Crea una colección del tipo especificado.                                                                                             | `Collection`                                       |
| `toMap(Function k, Function v)`          | Crea un mapa usando funciones para mapear las claves y valores, una función de fusión opcional y un proveedor de tipo de mapa opcional. | `Map<K, V>`                                        |
| `toMap(Function k, Function v, BinaryOperator m)` |                                                                                                                                         |                                                    |
| `toMap(Function k, Function v, BinaryOperator m, Supplier s)` |                                                                                                                                         |                                                    |

### Coleccionando Usando *Collectors* Básicos

Afortunadamente, muchos de estos *collectors* funcionan de la misma manera. Veamos un ejemplo.

```java
var ohMy = Stream.of("lions", "tigers", "bears");
String result = ohMy.collect(Collectors.joining(", "));
System.out.println(result); // lions, tigers, bears
```

Observa cómo los *collectors* predefinidos están en la clase `Collectors` en lugar de en la interfaz `Collector`. Este es un tema común, que viste con `Collection` versus `Collections`. De hecho, verás este patrón nuevamente en el Capítulo 20, “NIO.2”, al trabajar con `Paths` y `Path`, y otros tipos relacionados.

Pasamos el *collector* predefinido `joining()` al método `collect()`. Todos los elementos del stream se fusionan luego en una sola cadena con el delimitador especificado entre cada elemento. Es importante pasar el `Collector` al método `collect`. Este existe para ayudar a recopilar elementos. Un `Collector` no hace nada por sí mismo.

Intentemos con otro. ¿Cuál es la longitud promedio de los tres nombres de animales?

```java
var ohMy = Stream.of("lions", "tigers", "bears");
Double result = ohMy.collect(Collectors.averagingInt(String::length));
System.out.println(result); // 5.333333333333333
```

El patrón es el mismo. Pasamos un *collector* a `collect()`, y él realiza el promedio por nosotros. En esta ocasión, necesitábamos pasar una función para indicarle al *collector* qué promediar. Usamos una referencia de método, que devuelve un `int` al ejecutarse. Con streams primitivos, el resultado de un promedio siempre fue un `double`, independientemente del tipo que se promediara. Para *collectors*, es un `Double` ya que estos necesitan un objeto.

A menudo, te encontrarás interactuando con código que fue escrito sin streams. Esto significa que esperará un tipo `Collection` en lugar de un tipo `Stream`. No hay problema. Aún puedes expresarte usando un Stream y luego convertir a una Collection al final, por ejemplo:

```java
var ohMy = Stream.of("lions", "tigers", "bears");
TreeSet<String> result = ohMy
    .filter(s -> s.startsWith("t"))
    .collect(Collectors.toCollection(TreeSet::new));
System.out.println(result); // [tigers]
```

Esta vez tenemos las tres partes del *pipeline* del stream. `Stream.of()` es la fuente del stream. La operación intermedia es `filter()`. Finalmente, la operación terminal es `collect()`, que crea un `TreeSet`. Si no nos importara qué implementación de `Set` obtenemos, podríamos haber escrito `Collectors.toSet()` en su lugar.

En este punto, deberías ser capaz de usar todos los *collectors* en la Tabla 15.13 excepto `groupingBy()`, `mapping()`, `partitioningBy()` y `toMap()`.
