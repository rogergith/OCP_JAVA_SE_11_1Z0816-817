### USANDO STREAMS

Un **stream** en Java es una secuencia de datos. Una **tubería de stream** consiste en las operaciones que se ejecutan en un stream para producir un resultado. Primero, veremos el flujo de las tuberías conceptualmente. Después de eso, realmente nos adentraremos en el código.

### COMPRENDIENDO EL FLUJO DE LA TUBERÍA

Piensa en una tubería de stream como una línea de ensamblaje en una fábrica. Supongamos que estamos operando una línea de ensamblaje para hacer letreros para las exhibiciones de animales en el zoológico. Tenemos una serie de tareas. Es trabajo de una persona sacar letreros de una caja. Es trabajo de una segunda persona pintar el letrero. Es trabajo de una tercera persona estampar el nombre del animal en el letrero. Es trabajo de la última persona poner el letrero completado en una caja para ser llevado a la exhibición adecuada.

Observa que la segunda persona no puede hacer nada hasta que un letrero haya sido sacado de la caja por la primera persona. De manera similar, la tercera persona no puede hacer nada hasta que un letrero haya sido pintado, y la última persona no puede hacer nada hasta que esté estampar.

La línea de ensamblaje para hacer letreros es finita. Una vez que procesamos el contenido de nuestra caja de letreros, terminamos. Los **streams finitos** tienen un límite. Otras líneas de ensamblaje esencialmente corren para siempre, como una de producción de alimentos. Por supuesto, se detienen en algún momento cuando la fábrica cierra, pero finge que eso no sucede. O piensa en un ciclo de amanecer/atardecer como infinito, ya que no termina por un período de tiempo inusualmente largo.

Otra característica importante de una línea de ensamblaje es que cada persona toca cada elemento para realizar su operación y luego esa pieza de datos desaparece. No regresa. La siguiente persona la maneja en ese punto. Esto es diferente de las listas y colas que viste en el capítulo anterior. Con una lista, puedes acceder a cualquier elemento en cualquier momento. Con una cola, estás limitado en qué elementos puedes acceder, pero todos los elementos están allí. Con streams, los datos no se generan de antemano; se crean cuando se necesitan. Esto es un ejemplo de **evaluación perezosa (lazy evaluation)**, que retrasa la ejecución hasta que es necesario.

Muchas cosas pueden suceder en las estaciones de la línea de ensamblaje a lo largo del camino. En la programación funcional, esto se llama **operaciones de stream**. Al igual que con la línea de ensamblaje, las operaciones ocurren en una tubería. Alguien tiene que iniciar y terminar el trabajo, y puede haber cualquier número de estaciones en medio. Después de todo, ¡un trabajo con una sola persona no es una línea de ensamblaje! Hay tres partes en una tubería de stream, como se muestra en la **Figura 15.2**.

- **Fuente**: De dónde viene el stream.
- **Operaciones intermedias**: Transforma el stream en otro. Puede haber tan pocas o tantas operaciones intermedias como desees. Dado que los streams usan evaluación perezosa, las operaciones intermedias no se ejecutan hasta que la operación terminal se ejecuta.
- **Operación terminal**: Produce un resultado. Dado que los streams solo pueden usarse una vez, el stream ya no es válido después de que una operación terminal se completa.

### USANDO STREAMS

Un **stream** en Java es una secuencia de datos. Una **tubería de stream** consiste en las operaciones que se ejecutan en un stream para producir un resultado. Primero, veremos el flujo de las tuberías conceptualmente. Después de eso, realmente nos adentraremos en el código.

### COMPRENDIENDO EL FLUJO DE LA TUBERÍA

Piensa en una tubería de stream como una línea de ensamblaje en una fábrica. Supongamos que estamos operando una línea de ensamblaje para hacer letreros para las exhibiciones de animales en el zoológico. Tenemos una serie de tareas. Es trabajo de una persona sacar letreros de una caja. Es trabajo de una segunda persona pintar el letrero. Es trabajo de una tercera persona estampar el nombre del animal en el letrero. Es trabajo de la última persona poner el letrero completado en una caja para ser llevado a la exhibición adecuada.

Observa que la segunda persona no puede hacer nada hasta que un letrero haya sido sacado de la caja por la primera persona. De manera similar, la tercera persona no puede hacer nada hasta que un letrero haya sido pintado, y la última persona no puede hacer nada hasta que esté estampar.

La línea de ensamblaje para hacer letreros es finita. Una vez que procesamos el contenido de nuestra caja de letreros, terminamos. Los **streams finitos** tienen un límite. Otras líneas de ensamblaje esencialmente corren para siempre, como una de producción de alimentos. Por supuesto, se detienen en algún momento cuando la fábrica cierra, pero finge que eso no sucede. O piensa en un ciclo de amanecer/atardecer como infinito, ya que no termina por un período de tiempo inusualmente largo.

Otra característica importante de una línea de ensamblaje es que cada persona toca cada elemento para realizar su operación y luego esa pieza de datos desaparece. No regresa. La siguiente persona la maneja en ese punto. Esto es diferente de las listas y colas que viste en el capítulo anterior. Con una lista, puedes acceder a cualquier elemento en cualquier momento. Con una cola, estás limitado en qué elementos puedes acceder, pero todos los elementos están allí. Con streams, los datos no se generan de antemano; se crean cuando se necesitan. Esto es un ejemplo de **evaluación perezosa (lazy evaluation)**, que retrasa la ejecución hasta que es necesario.

Muchas cosas pueden suceder en las estaciones de la línea de ensamblaje a lo largo del camino. En la programación funcional, esto se llama **operaciones de stream**. Al igual que con la línea de ensamblaje, las operaciones ocurren en una tubería. Alguien tiene que iniciar y terminar el trabajo, y puede haber cualquier número de estaciones en medio. Después de todo, ¡un trabajo con una sola persona no es una línea de ensamblaje! Hay tres partes en una tubería de stream, como se muestra en la **Figura 15.2**.

#### TABLA 15.4 Operaciones intermedias vs. terminales

| Escenario                                      | Operación intermedia | Operación terminal |
|------------------------------------------------|----------------------|---------------------|
| ¿Parte requerida de una tubería útil?          | No                   | Sí                  |
| ¿Puede existir múltiples veces en una tubería? | Sí                   | No                  |
| ¿El tipo de retorno es un tipo de stream?      | Sí                   | No                  |
| ¿Se ejecuta al llamar el método?               | No                   | Sí                  |
| ¿El stream es válido después de la llamada?    | Sí                   | No                  |

Una fábrica típicamente tiene un capataz que supervisa el trabajo. Java actúa como el capataz al trabajar con tuberías de streams. Este es un rol realmente importante, especialmente al tratar con evaluación perezosa y streams infinitos. Piensa en declarar el stream como dar instrucciones al capataz. A medida que el capataz descubre lo que se necesita hacer, establece las estaciones y dice a los trabajadores cuáles serán sus tareas. Sin embargo, los trabajadores no comienzan hasta que el capataz les indica que inicien. El capataz espera hasta que ve la operación terminal para realmente iniciar el trabajo. También supervisa el trabajo y detiene la línea tan pronto como el trabajo está completo.

Veamos algunos ejemplos de esto. No estamos usando código en estos ejemplos porque es realmente importante entender el concepto de la tubería de streams antes de empezar a escribir el código. La **Figura 15.3** muestra una tubería de stream con una operación intermedia.

Primero, él ve que la fuente está sacando letreros de la caja. El capataz asigna a un trabajador en la mesa para desempacar la caja y le indica que espere una señal para comenzar. Luego, el capataz ve la operación intermedia para pintar el letrero. Asigna a un trabajador con pintura y le indica que espere una señal para comenzar. Finalmente, el capataz ve la operación terminal para poner los letreros en una pila. Asigna a un trabajador para hacer esto y grita que los tres trabajadores deben empezar.

Supongamos que hay dos letreros en la caja. El Paso 1 es que el primer trabajador saca un letrero de la caja y se lo entrega al segundo trabajador. El Paso 2 es que el segundo trabajador lo pinta y se lo entrega al tercer trabajador. El Paso 3 es que el tercer trabajador lo coloca en la pila. Los Pasos 4–6 son el mismo proceso para el otro letrero. Luego, el capataz ve que no quedan más letreros y cierra toda la operación.

El capataz es inteligente. Puede tomar decisiones sobre la mejor manera de realizar el trabajo según lo que se necesita. Como ejemplo, exploremos la tubería de stream en la **Figura 15.4**.

El capataz aún ve una fuente que saca letreros de la caja y asigna a un trabajador para que lo haga bajo comando. Aún ve una operación intermedia para pintar y asigna a otro trabajador con instrucciones para esperar y luego pintar. Luego, ve un paso intermedio en el que solo necesitamos dos letreros. Asigna a un trabajador para contar los letreros que pasan y le notifica cuando el trabajador ha visto dos. Finalmente, asigna a un trabajador para la operación terminal de poner los letreros en una pila.

Esta vez, supongamos que hay 10 letreros en la caja. Comenzamos como la última vez. El primer letrero avanza por la tubería. El segundo letrero también avanza por la tubería. Cuando la trabajadora encargada de contar ve el segundo letrero, le informa al capataz. El capataz permite que la trabajadora de la operación terminal termine su tarea y luego grita “detener la línea”. No importa que queden ocho letreros más en la caja. No los necesitamos, por lo que sería un trabajo innecesario pintarlos. ¡Y todos queremos evitar trabajos innecesarios!

De manera similar, el capataz habría detenido la línea después del primer letrero si la operación terminal hubiera sido encontrar el primer letrero que se crea.
