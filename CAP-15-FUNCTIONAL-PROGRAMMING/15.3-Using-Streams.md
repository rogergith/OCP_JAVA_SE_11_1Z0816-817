### USANDO STREAMS

Un **stream** en Java es una secuencia de datos. Una **tubería de stream** consiste en las operaciones que se ejecutan en un stream para producir un resultado. Primero, veremos el flujo de las tuberías conceptualmente. Después de eso, realmente nos adentraremos en el código.

### COMPRENDIENDO EL FLUJO DE LA TUBERÍA

Piensa en una tubería de stream como una línea de ensamblaje en una fábrica. Supongamos que estamos operando una línea de ensamblaje para hacer letreros para las exhibiciones de animales en el zoológico. Tenemos una serie de tareas. Es trabajo de una persona sacar letreros de una caja. Es trabajo de una segunda persona pintar el letrero. Es trabajo de una tercera persona estampar el nombre del animal en el letrero. Es trabajo de la última persona poner el letrero completado en una caja para ser llevado a la exhibición adecuada.

Observa que la segunda persona no puede hacer nada hasta que un letrero haya sido sacado de la caja por la primera persona. De manera similar, la tercera persona no puede hacer nada hasta que un letrero haya sido pintado, y la última persona no puede hacer nada hasta que esté estampar.

La línea de ensamblaje para hacer letreros es finita. Una vez que procesamos el contenido de nuestra caja de letreros, terminamos. Los **streams finitos** tienen un límite. Otras líneas de ensamblaje esencialmente corren para siempre, como una de producción de alimentos. Por supuesto, se detienen en algún momento cuando la fábrica cierra, pero finge que eso no sucede. O piensa en un ciclo de amanecer/atardecer como infinito, ya que no termina por un período de tiempo inusualmente largo.

Otra característica importante de una línea de ensamblaje es que cada persona toca cada elemento para realizar su operación y luego esa pieza de datos desaparece. No regresa. La siguiente persona la maneja en ese punto. Esto es diferente de las listas y colas que viste en el capítulo anterior. Con una lista, puedes acceder a cualquier elemento en cualquier momento. Con una cola, estás limitado en qué elementos puedes acceder, pero todos los elementos están allí. Con streams, los datos no se generan de antemano; se crean cuando se necesitan. Esto es un ejemplo de **evaluación perezosa (lazy evaluation)**, que retrasa la ejecución hasta que es necesario.

Muchas cosas pueden suceder en las estaciones de la línea de ensamblaje a lo largo del camino. En la programación funcional, esto se llama **operaciones de stream**. Al igual que con la línea de ensamblaje, las operaciones ocurren en una tubería. Alguien tiene que iniciar y terminar el trabajo, y puede haber cualquier número de estaciones en medio. Después de todo, ¡un trabajo con una sola persona no es una línea de ensamblaje! Hay tres partes en una tubería de stream, como se muestra en la **Figura 15.2**.

- **Fuente**: De dónde viene el stream.
- **Operaciones intermedias**: Transforma el stream en otro. Puede haber tan pocas o tantas operaciones intermedias como desees. Dado que los streams usan evaluación perezosa, las operaciones intermedias no se ejecutan hasta que la operación terminal se ejecuta.
- **Operación terminal**: Produce un resultado. Dado que los streams solo pueden usarse una vez, el stream ya no es válido después de que una operación terminal se completa.

### USANDO STREAMS

Un **stream** en Java es una secuencia de datos. Una **tubería de stream** consiste en las operaciones que se ejecutan en un stream para producir un resultado. Primero, veremos el flujo de las tuberías conceptualmente. Después de eso, realmente nos adentraremos en el código.

### COMPRENDIENDO EL FLUJO DE LA TUBERÍA

Piensa en una tubería de stream como una línea de ensamblaje en una fábrica. Supongamos que estamos operando una línea de ensamblaje para hacer letreros para las exhibiciones de animales en el zoológico. Tenemos una serie de tareas. Es trabajo de una persona sacar letreros de una caja. Es trabajo de una segunda persona pintar el letrero. Es trabajo de una tercera persona estampar el nombre del animal en el letrero. Es trabajo de la última persona poner el letrero completado en una caja para ser llevado a la exhibición adecuada.

Observa que la segunda persona no puede hacer nada hasta que un letrero haya sido sacado de la caja por la primera persona. De manera similar, la tercera persona no puede hacer nada hasta que un letrero haya sido pintado, y la última persona no puede hacer nada hasta que esté estampar.

La línea de ensamblaje para hacer letreros es finita. Una vez que procesamos el contenido de nuestra caja de letreros, terminamos. Los **streams finitos** tienen un límite. Otras líneas de ensamblaje esencialmente corren para siempre, como una de producción de alimentos. Por supuesto, se detienen en algún momento cuando la fábrica cierra, pero finge que eso no sucede. O piensa en un ciclo de amanecer/atardecer como infinito, ya que no termina por un período de tiempo inusualmente largo.

Otra característica importante de una línea de ensamblaje es que cada persona toca cada elemento para realizar su operación y luego esa pieza de datos desaparece. No regresa. La siguiente persona la maneja en ese punto. Esto es diferente de las listas y colas que viste en el capítulo anterior. Con una lista, puedes acceder a cualquier elemento en cualquier momento. Con una cola, estás limitado en qué elementos puedes acceder, pero todos los elementos están allí. Con streams, los datos no se generan de antemano; se crean cuando se necesitan. Esto es un ejemplo de **evaluación perezosa (lazy evaluation)**, que retrasa la ejecución hasta que es necesario.

Muchas cosas pueden suceder en las estaciones de la línea de ensamblaje a lo largo del camino. En la programación funcional, esto se llama **operaciones de stream**. Al igual que con la línea de ensamblaje, las operaciones ocurren en una tubería. Alguien tiene que iniciar y terminar el trabajo, y puede haber cualquier número de estaciones en medio. Después de todo, ¡un trabajo con una sola persona no es una línea de ensamblaje! Hay tres partes en una tubería de stream, como se muestra en la **Figura 15.2**.

#### TABLA 15.4 Operaciones intermedias vs. terminales

| Escenario                                      | Operación intermedia | Operación terminal |
|------------------------------------------------|----------------------|---------------------|
| ¿Parte requerida de una tubería útil?          | No                   | Sí                  |
| ¿Puede existir múltiples veces en una tubería? | Sí                   | No                  |
| ¿El tipo de retorno es un tipo de stream?      | Sí                   | No                  |
| ¿Se ejecuta al llamar el método?               | No                   | Sí                  |
| ¿El stream es válido después de la llamada?    | Sí                   | No                  |

Una fábrica típicamente tiene un capataz que supervisa el trabajo. Java actúa como el capataz al trabajar con tuberías de streams. Este es un rol realmente importante, especialmente al tratar con evaluación perezosa y streams infinitos. Piensa en declarar el stream como dar instrucciones al capataz. A medida que el capataz descubre lo que se necesita hacer, establece las estaciones y dice a los trabajadores cuáles serán sus tareas. Sin embargo, los trabajadores no comienzan hasta que el capataz les indica que inicien. El capataz espera hasta que ve la operación terminal para realmente iniciar el trabajo. También supervisa el trabajo y detiene la línea tan pronto como el trabajo está completo.

Veamos algunos ejemplos de esto. No estamos usando código en estos ejemplos porque es realmente importante entender el concepto de la tubería de streams antes de empezar a escribir el código. La **Figura 15.3** muestra una tubería de stream con una operación intermedia.

Primero, él ve que la fuente está sacando letreros de la caja. El capataz asigna a un trabajador en la mesa para desempacar la caja y le indica que espere una señal para comenzar. Luego, el capataz ve la operación intermedia para pintar el letrero. Asigna a un trabajador con pintura y le indica que espere una señal para comenzar. Finalmente, el capataz ve la operación terminal para poner los letreros en una pila. Asigna a un trabajador para hacer esto y grita que los tres trabajadores deben empezar.

Supongamos que hay dos letreros en la caja. El Paso 1 es que el primer trabajador saca un letrero de la caja y se lo entrega al segundo trabajador. El Paso 2 es que el segundo trabajador lo pinta y se lo entrega al tercer trabajador. El Paso 3 es que el tercer trabajador lo coloca en la pila. Los Pasos 4–6 son el mismo proceso para el otro letrero. Luego, el capataz ve que no quedan más letreros y cierra toda la operación.

El capataz es inteligente. Puede tomar decisiones sobre la mejor manera de realizar el trabajo según lo que se necesita. Como ejemplo, exploremos la tubería de stream en la **Figura 15.4**.

El capataz aún ve una fuente que saca letreros de la caja y asigna a un trabajador para que lo haga bajo comando. Aún ve una operación intermedia para pintar y asigna a otro trabajador con instrucciones para esperar y luego pintar. Luego, ve un paso intermedio en el que solo necesitamos dos letreros. Asigna a un trabajador para contar los letreros que pasan y le notifica cuando el trabajador ha visto dos. Finalmente, asigna a un trabajador para la operación terminal de poner los letreros en una pila.

Esta vez, supongamos que hay 10 letreros en la caja. Comenzamos como la última vez. El primer letrero avanza por la tubería. El segundo letrero también avanza por la tubería. Cuando la trabajadora encargada de contar ve el segundo letrero, le informa al capataz. El capataz permite que la trabajadora de la operación terminal termine su tarea y luego grita “detener la línea”. No importa que queden ocho letreros más en la caja. No los necesitamos, por lo que sería un trabajo innecesario pintarlos. ¡Y todos queremos evitar trabajos innecesarios!

De manera similar, el capataz habría detenido la línea después del primer letrero si la operación terminal hubiera sido encontrar el primer letrero que se crea.

### CREANDO FUENTES DE STREAMS

En Java, los streams de los que hemos estado hablando están representados por la interfaz `Stream<T>`, definida en el paquete `java.util.stream`.

#### Creando Streams Finitos

Para simplificar, comenzaremos con streams finitos. Hay varias maneras de crearlos.

```java
// Línea 11
Stream<String> empty = Stream.empty(); // count = 0

// Línea 12
Stream<Integer> singleElement = Stream.of(1); // count = 1

// Línea 13
Stream<Integer> fromArray = Stream.of(1, 2, 3); // count = 3
```

La línea 11 muestra cómo crear un stream vacío. La línea 12 muestra cómo crear un stream con un solo elemento. La línea 13 muestra cómo crear un stream a partir de un varargs. Sin duda has notado que en la línea 13 no hay un array. La firma del método usa varargs, lo que te permite especificar un array o elementos individuales.

Java también proporciona una manera conveniente de convertir una `Collection` en un stream.

```java
// Línea 14
var list = List.of("a", "b", "c");

// Línea 15
Stream<String> fromList = list.stream();
```

La línea 15 muestra que es una simple llamada de método para crear un stream a partir de una lista. Esto es útil ya que tales conversiones son comunes.

### CREANDO UN STREAM PARALELO

Es igual de fácil crear un stream paralelo a partir de una lista.

```java
// Línea 24
var list = List.of("a", "b", "c");

// Línea 25
Stream<String> fromListParallel = list.parallelStream();
```

Esta es una excelente característica porque puedes escribir código que utiliza concurrencia incluso antes de aprender qué es un hilo. Usar streams paralelos es como configurar múltiples mesas de trabajadores que pueden realizar la misma tarea. Pintar sería mucho más rápido si pudiéramos tener cinco pintores pintando letreros en lugar de solo uno. Solo ten en cuenta que algunas tareas no pueden hacerse en paralelo, como guardar los letreros en el orden en que fueron creados en el stream. Además, debes ser consciente de que hay un costo en la coordinación del trabajo, por lo que para streams más pequeños, podría ser más rápido hacerlo de manera secuencial. Aprenderás mucho más sobre cómo ejecutar tareas concurrentemente en el Capítulo 18.

### RESUMEN

- **Streams Paralelos**: Permiten procesar datos de manera concurrente, aprovechando múltiples hilos de ejecución para mejorar el rendimiento en tareas que pueden ser paralelizadas.
- **Creación de Streams Paralelos**: Se pueden crear fácilmente a partir de colecciones utilizando el método `parallelStream()`.
- **Consideraciones**:
  - **Tareas Adecuadas**: No todas las tareas son adecuadas para la paralelización. Tareas que dependen del orden o que no pueden ejecutarse simultáneamente deben evitarse.
  - **Costo de Coordinación**: La coordinación entre hilos puede introducir sobrecarga, por lo que para streams pequeños, puede ser más eficiente procesarlos de manera secuencial.
  - **Evaluación Perezosa**: Al igual que los streams secuenciales, los streams paralelos también utilizan evaluación perezosa, ejecutando las operaciones intermedias solo cuando se invoca una operación terminal.

### EJEMPLO ADICIONAL

Para ilustrar cómo crear y utilizar un stream paralelo, consideremos el siguiente ejemplo:

```java
import java.util.List;
import java.util.stream.Stream;

public class ParallelStreamExample {
    public static void main(String[] args) {
        var list = List.of("a", "b", "c", "d", "e", "f", "g", "h", "i", "j");
        Stream<String> fromListParallel = list.parallelStream();

        fromListParallel.forEach(elemento -> {
            System.out.println("Procesando: " + elemento + " en el hilo " + Thread.currentThread().getName());
        });
    }
}
```

#### Salida Esperada:
```
Procesando: a en el hilo ForkJoinPool.commonPool-worker-1
Procesando: b en el hilo ForkJoinPool.commonPool-worker-2
Procesando: c en el hilo ForkJoinPool.commonPool-worker-3
Procesando: d en el hilo ForkJoinPool.commonPool-worker-4
Procesando: e en el hilo ForkJoinPool.commonPool-worker-1
Procesando: f en el hilo ForkJoinPool.commonPool-worker-2
Procesando: g en el hilo ForkJoinPool.commonPool-worker-3
Procesando: h en el hilo ForkJoinPool.commonPool-worker-4
Procesando: i en el hilo ForkJoinPool.commonPool-worker-1
Procesando: j en el hilo ForkJoinPool.commonPool-worker-2
```

En este ejemplo:

1. **Creación del Stream Paralelo**: `list.parallelStream()` crea un stream paralelo a partir de la lista de elementos.
2. **Operación Terminal**: `.forEach(...)` procesa cada elemento del stream en paralelo, ejecutando la operación en diferentes hilos.
3. **Salida Concurrente**: La salida muestra que los elementos son procesados en diferentes hilos, lo que ilustra la concurrencia del stream paralelo.

### CONCLUSIÓN

Entender cómo crear y utilizar streams paralelos en Java te permite aprovechar mejor los recursos del sistema y mejorar el rendimiento de tus aplicaciones. Sin embargo, es importante evaluar cuidadosamente cuándo usar streams paralelos para evitar costos innecesarios de coordinación y asegurar que las tareas sean adecuadas para la paralelización.

Recuerda practicar estos conceptos y ejemplos para familiarizarte con el uso de streams paralelos en tus propios proyectos Java.

### CREANDO STREAMS INFINITOS

Hasta ahora, esto no es particularmente impresionante. Podríamos hacer todo esto con listas. Sin embargo, no podemos crear una lista infinita, lo que hace que los streams sean más poderosos.

```java
// Línea 17
Stream<Double> randoms = Stream.generate(Math::random); // Genera un stream de números aleatorios

// Línea 18
Stream<Integer> oddNumbers = Stream.iterate(1, n -> n + 2); // Genera un stream de números impares
```

La línea 17 genera un stream de números aleatorios. ¿Cuántos números aleatorios? La cantidad que necesites. Si llamas a `randoms.forEach(System.out::println)`, el programa imprimirá números aleatorios hasta que lo detengas. Más adelante en el capítulo, aprenderás sobre operaciones como `limit()` para convertir el stream infinito en un stream finito.

La línea 18 te da más control. El método `iterate()` toma una semilla o valor inicial como primer parámetro. Este es el primer elemento que formará parte del stream. El otro parámetro es una expresión lambda que recibe el valor anterior y genera el siguiente valor. Al igual que con el ejemplo de los números aleatorios, seguirá produciendo números impares mientras los necesites.

> Si intentas llamar a `System.out.print(stream)`, obtendrás algo como lo siguiente:

```java
java.util.stream.ReferencePipeline$3@4517d9a3
```

> Esto es diferente de una `Collection` donde ves el contenido. No necesitas saber esto para el examen. Lo mencionamos para que no te sorprenda al escribir código para practicar.

¿Qué pasa si solo quieres números impares menores de 100? Java 9 introdujo una versión sobrecargada de `iterate()` que ayuda precisamente con eso.

```java
// Línea 19
Stream<Integer> oddNumberUnder100 = Stream.iterate(
    1, // semilla
    n -> n < 100, // Predicado para especificar cuándo terminar
    n -> n + 2 // UnaryOperator para obtener el siguiente valor
);
```

Este método toma tres parámetros. Observa cómo están separados por comas (,), al igual que todos los demás métodos. El examen podría intentar engañarte usando puntos y comas (`;`) ya que es similar a un bucle `for`. Similar a un bucle `for`, debes asegurarte de no estar creando accidentalmente un stream infinito.





### REVISIONANDO LOS MÉTODOS DE CREACIÓN DE STREAMS

Para repasar, asegúrate de conocer todos los métodos en la **Tabla 15.5**. Estas son las formas de crear una fuente para streams, dado una instancia de `Collection` llamada `coll`.

#### TABLA 15.5 Creando una fuente

| Método                               | ¿Finito o Infinito? | Notas                                                                                              |
|--------------------------------------|----------------------|----------------------------------------------------------------------------------------------------|
| `Stream.empty()`                     | Finito               | Crea un stream con cero elementos                                                                   |
| `Stream.of(varargs)`                 | Finito               | Crea un stream con los elementos listados                                                           |
| `coll.stream()`                      | Finito               | Crea un stream a partir de una colección                                                            |
| `coll.parallelStream()`              | Finito               | Crea un stream a partir de una colección donde el stream puede ejecutarse en paralelo               |
| `Stream.generate(supplier)`          | Infinito             | Crea un stream llamando al `Supplier` para cada elemento según se solicita                          |
| `Stream.iterate(seed, unaryOperator)`| Infinito             | Crea un stream usando la semilla para el primer elemento y luego llamando al `UnaryOperator` para cada elemento subsiguiente según se solicita |
| `Stream.iterate(seed, predicate, unaryOperator)` | Finito o Infinito | Crea un stream usando la semilla para el primer elemento y luego llamando al `UnaryOperator` para cada elemento subsiguiente según se solicita. Se detiene si el `Predicate` devuelve `false` |

#### Explicación de los Métodos

- **`Stream.empty()`**: Este método crea un stream vacío sin ningún elemento. Es útil cuando necesitas retornar un stream pero no tienes elementos que proporcionar.

    ```java
    Stream<String> empty = Stream.empty(); // count = 0
    ```

- **`Stream.of(varargs)`**: Crea un stream con los elementos proporcionados. Puedes pasar una lista de elementos separados por comas o un array.

    ```java
    Stream<Integer> singleElement = Stream.of(1); // count = 1
    Stream<Integer> fromArray = Stream.of(1, 2, 3); // count = 3
    ```

- **`coll.stream()`**: Convierte una colección en un stream. Es una forma sencilla y común de crear streams a partir de colecciones existentes.

    ```java
    var list = List.of("a", "b", "c");
    Stream<String> fromList = list.stream();
    ```

- **`coll.parallelStream()`**: Similar a `coll.stream()`, pero crea un stream que puede ejecutarse en paralelo, aprovechando múltiples hilos de ejecución para mejorar el rendimiento en operaciones que pueden ser paralelizadas.

    ```java
    var list = List.of("a", "b", "c");
    Stream<String> fromListParallel = list.parallelStream();
    ```

- **`Stream.generate(supplier)`**: Crea un stream infinito generando elementos mediante un `Supplier`. Cada vez que se solicita un elemento, se llama al `Supplier` para obtener el siguiente valor.

    ```java
    Stream<Double> randoms = Stream.generate(Math::random); // Genera un stream de números aleatorios
    ```

- **`Stream.iterate(seed, unaryOperator)`**: Crea un stream infinito comenzando con una semilla y aplicando un `UnaryOperator` para generar cada elemento subsiguiente.

    ```java
    Stream<Integer> oddNumbers = Stream.iterate(1, n -> n + 2); // Genera un stream de números impares
    ```

- **`Stream.iterate(seed, predicate, unaryOperator)`**: Introducido en Java 9, este método permite crear un stream finito o infinito utilizando una semilla, un `Predicate` para determinar cuándo detenerse y un `UnaryOperator` para generar los elementos.

    ```java
    Stream<Integer> oddNumberUnder100 = Stream.iterate(
        1, // semilla
        n -> n < 100, // Predicate para especificar cuándo terminar
        n -> n + 2  // UnaryOperator para obtener el siguiente valor
    );
    ```


### USANDO OPERACIONES TERMINALES COMUNES

Puedes realizar una operación terminal sin ninguna operación intermedia, pero no al revés. Por eso hablaremos de las operaciones terminales primero. Las reducciones son un tipo especial de operación terminal donde todo el contenido del stream se combina en un solo primitivo u objeto. Por ejemplo, podrías tener un `int` o una `Collection`.

La **Tabla 15.6** resume esta sección. Siéntete libre de usarla como guía para recordar los puntos más importantes mientras repasamos cada uno individualmente. Los explicamos de lo más simple a lo más complejo en lugar de alfabéticamente.

#### TABLA 15.6 Operaciones terminales de stream

| Método                               | Qué sucede para streams infinitos | Valor de retorno | Reducción |
|--------------------------------------|-----------------------------------|-------------------|-----------|
| `count()`                            | No termina                        | `long`            | Sí        |
| `min()` `max()`                      | No termina                        | `Optional<T>`     | Sí        |
| `findAny()` `findFirst()`            | Termina                           | `Optional<T>`     | No        |
| `allMatch()` `anyMatch()` `noneMatch()` | A veces termina                  | `boolean`         | No        |
| `forEach()`                          | No termina                        | `void`            | No        |
| `reduce()`                           | No termina                        | Varía             | Sí        |
| `collect()`                          | No termina                        | Varía             | Sí        |

### count()s

El método `count()` determina el número de elementos en un stream finito. Para un stream infinito, nunca termina. ¿Por qué? Cuenta desde 1 hasta el infinito y avísanos cuando termines. O mejor dicho, no hagas eso porque preferimos que estudies para el examen en lugar de pasar el resto de tu vida contando. El método `count()` es una reducción porque examina cada elemento en el stream y devuelve un solo valor. La firma del método es la siguiente:

```java
long count()
```

Este ejemplo muestra cómo llamar a `count()` en un stream finito:

```java
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
System.out.println(s.count()); // 3
```

### min() y max()

Los métodos `min()` y `max()` te permiten pasar un comparador personalizado y encontrar el valor más pequeño o más grande en un stream finito según ese orden de clasificación. Al igual que el método `count()`, `min()` y `max()` se quedan colgados en un stream infinito porque no pueden estar seguros de que un valor más pequeño o más grande no venga más adelante en el stream. Ambos métodos son reducciones porque devuelven un solo valor después de examinar todo el stream. Las firmas de los métodos son las siguientes:

```java
Optional<T> min(Comparator<? super T> comparator)
Optional<T> max(Comparator<? super T> comparator)
```

Este ejemplo encuentra el animal con menos letras en su nombre:

```java
Stream<String> s = Stream.of("monkey", "ape", "bonobo");
Optional<String> min = s.min((s1, s2) -> s1.length() - s2.length());
min.ifPresent(System.out::println); // ape
```

Observa que el código devuelve un `Optional` en lugar del valor. Esto permite que el método especifique que no se encontró un mínimo o máximo. Usamos el método `ifPresent()` de `Optional` y una referencia a un método para imprimir el mínimo solo si se encuentra uno. Como ejemplo de dónde no hay un mínimo, veamos un stream vacío.

```java
Optional<?> minEmpty = Stream.empty().min((s1, s2) -> 0);
System.out.println(minEmpty.isPresent()); // false
```

Dado que el stream está vacío, el comparador nunca se llama y no hay ningún valor presente en el `Optional`.

### RESUMEN

- **`min()` y `max()`**: Permiten encontrar el valor mínimo o máximo en un stream finito usando un comparador personalizado.
- **Retorno**: Devuelven un `Optional<T>` para manejar la posibilidad de que no se encuentre ningún valor.
- **Reducción**: Ambos métodos son operaciones de reducción ya que combinan todos los elementos del stream en un solo resultado.
- **Streams Infinitos**: En streams infinitos, `min()` y `max()` no terminan porque siempre puede haber un valor más pequeño o más grande.
- **Uso de `Optional`**: Permite manejar de manera segura la ausencia de un valor mínimo o máximo, evitando excepciones.

Recuerda practicar el uso de estos métodos y entender cómo funcionan con diferentes tipos de streams para prepararte adecuadamente para el examen.


### findAny() y findFirst()

Los métodos `findAny()` y `findFirst()` devuelven un elemento del stream a menos que el stream esté vacío. Si el stream está vacío, devuelven un `Optional` vacío. Este es el primer método que has visto que puede terminar con un stream infinito. Dado que Java genera solo la cantidad de stream que necesitas, el stream infinito solo necesita generar un elemento.

Como su nombre lo indica, el método `findAny()` puede devolver cualquier elemento del stream. Cuando se llama en los streams que has visto hasta ahora, comúnmente devuelve el primer elemento, aunque este comportamiento no está garantizado. Como verás en el Capítulo 18, el método `findAny()` es más probable que devuelva un elemento aleatorio cuando se trabaja con streams paralelos.

Estos métodos son operaciones terminales pero no reducciones. La razón es que a veces devuelven sin procesar todos los elementos. Esto significa que devuelven un valor basado en el stream pero no reducen todo el stream a un solo valor.

Las firmas de los métodos son las siguientes:
```java
Optional<T> findAny()
Optional<T> findFirst()
```

Este ejemplo encuentra un animal:
```java
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
Stream<String> infinite = Stream.generate(() -> "chimp");
s.findAny().ifPresent(System.out::println); // monkey (usualmente)
infinite.findAny().ifPresent(System.out::println); // chimp
```

Encontrar cualquier coincidencia es más útil de lo que parece. A veces solo queremos muestrear los resultados y obtener un elemento representativo, pero no necesitamos desperdiciar el procesamiento generándolos todos. Después de todo, si planeamos trabajar solo con un elemento, ¿por qué molestarse en mirar más?


> **NOTA:** ¿Qué pasa si necesitas tanto el valor mínimo como el máximo del mismo stream? Por ahora, no puedes tener ambos, al menos no utilizando estos métodos. Recuerda, un stream solo puede tener una operación terminal. Una vez que se ha ejecutado una operación terminal, el stream no puede ser utilizado nuevamente. Como veremos más adelante en este capítulo, hay métodos de resumen integrados para algunos streams numéricos que calcularán un conjunto de valores para ti.

### allMatch(), anyMatch() y noneMatch()

Los métodos `allMatch()`, `anyMatch()` y `noneMatch()` buscan en un stream y devuelven información sobre cómo el stream se relaciona con el predicado. Estos pueden o no terminar para streams infinitos. Depende de los datos. Al igual que los métodos de búsqueda, no son reducciones porque no necesariamente miran todos los elementos.

Las firmas de los métodos son las siguientes:
```java
boolean anyMatch(Predicate<? super T> predicate)
boolean allMatch(Predicate<? super T> predicate)
boolean noneMatch(Predicate<? super T> predicate)
```

Este ejemplo verifica si los nombres de animales comienzan con letras:
```java
var list = List.of("monkey", "2", "chimp");
Stream<String> infinite = Stream.generate(() -> "chimp");
Predicate<String> pred = x -> Character.isLetter(x.charAt(0));
System.out.println(list.stream().anyMatch(pred)); // true
System.out.println(list.stream().allMatch(pred)); // false
System.out.println(list.stream().noneMatch(pred)); // false
System.out.println(infinite.anyMatch(pred)); // true
```

Esto muestra que podemos reutilizar el mismo predicado, pero necesitamos un stream diferente cada vez. El método `anyMatch()` devuelve true porque dos de los tres elementos coinciden. El método `allMatch()` devuelve false porque uno no coincide. El método `noneMatch()` también devuelve false porque uno coincide. En el stream infinito, se encuentra una coincidencia, por lo que la llamada termina. Si llamáramos a `allMatch()`, correría hasta que matáramos el programa.

> Recuerda que `allMatch()`, `anyMatch()` y `noneMatch()` devuelven un booleano. En contraste, los métodos de búsqueda devuelven un `Optional` porque retornan un elemento del stream.

### forEach()

Al igual que en el Java Collections Framework, es común iterar sobre los elementos de un stream. Como se espera, llamar a `forEach()` en un stream infinito no termina. Dado que no hay valor de retorno, no es una reducción.

Antes de usarlo, considera si otro enfoque sería mejor. Los desarrolladores que aprendieron a escribir bucles primero tienden a usarlos para todo. Por ejemplo, un bucle con una declaración `if` podría escribirse con un `filter`. Aprenderás sobre los filtros en la sección de operaciones intermedias.

La firma del método es la siguiente:

```java
void forEach(Consumer<? super T> action)
```

Observa que esta es la única operación terminal con un tipo de retorno `void`. Si quieres que algo suceda, tienes que hacer que suceda en el `Consumer`. Aquí tienes una forma de imprimir los elementos en el stream (hay otras formas, que cubriremos más adelante en el capítulo):

```java
Stream<String> s = Stream.of("Monkey", "Gorilla", "Bonobo");
s.forEach(System.out::print); // MonkeyGorillaBonobo
```

> Recuerda que puedes llamar a `forEach()` directamente en una `Collection` o en un `Stream`. No te confundas en el examen cuando veas ambos enfoques.

Observa que no puedes usar un bucle for tradicional en un stream.

```java
Stream<Integer> s = Stream.of(1);
for (Integer i : s) {} // NO COMPILA
```

Aunque `forEach()` suena como un bucle, en realidad es un operador terminal para streams. Los streams no pueden usarse como fuente en un bucle for-each porque no implementan la interfaz `Iterable`.


### reduce()
El método `reduce()` combina un stream en un solo objeto. Es una reducción, lo que significa que procesa todos los elementos. Las tres firmas del método son las siguientes:

```java
T reduce(T identity, BinaryOperator<T> accumulator)
Optional<T> reduce(BinaryOperator<T> accumulator)
<U> U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)
```

Tomemos cada una por turno. La forma más común de hacer una reducción es comenzar con un valor inicial y seguir fusionándolo con el siguiente valor. Piensa en cómo concatenarías un array de objetos String en un solo String sin programación funcional. Podría verse algo así:

```java
var array = new String[] { "w", "o", "l", "f" };
var result = "";
for (var s: array) result = result + s;
System.out.println(result); // wolf
```

La identidad es el valor inicial de la reducción, en este caso un String vacío. El acumulador combina el resultado actual con el valor actual en el stream. Con lambdas, podemos hacer lo mismo con un stream y una reducción:

```java
Stream<String> stream = Stream.of("w", "o", "l", "f");
String word = stream.reduce("", (s, c) -> s + c);
System.out.println(word); // wolf
```

Observa cómo todavía tenemos el String vacío como identidad. También seguimos concatenando los objetos String para obtener el siguiente valor. Incluso podemos reescribir esto con una referencia a método.

```java
Stream<String> stream = Stream.of("w", "o", "l", "f");
String word = stream.reduce("", String::concat);
System.out.println(word); // wolf
```

Probemos otro. ¿Puedes escribir una reducción para multiplicar todos los objetos Integer en un stream? Pruébalo. Nuestra solución se muestra aquí:

```java
Stream<Integer> stream = Stream.of(3, 5, 6);
System.out.println(stream.reduce(1, (a, b) -> a*b)); // 90
```

Establecemos la identidad en 1 y el acumulador en multiplicación. En muchos casos, la identidad no es realmente necesaria, por lo que Java nos permite omitirla. Cuando no especificas una identidad, se devuelve un `Optional` porque podría no haber datos. Hay tres opciones para lo que está en el `Optional`.

Si el stream está vacío, se devuelve un `Optional` vacío.
Si el stream tiene un elemento, se devuelve.
Si el stream tiene múltiples elementos, el acumulador se aplica para combinarlos.
La siguiente ilustra cada uno de estos escenarios:

```java
BinaryOperator<Integer> op = (a, b) -> a * b;
Stream<Integer> empty = Stream.empty();
Stream<Integer> oneElement = Stream.of(3);
Stream<Integer> threeElements = Stream.of(3, 5, 6);
empty.reduce(op).ifPresent(System.out::println); // no output
oneElement.reduce(op).ifPresent(System.out::println); // 3
threeElements.reduce(op).ifPresent(System.out::println); // 90
```

¿Por qué hay dos métodos similares? ¿Por qué no siempre requerir la identidad? Java podría haber hecho eso. Sin embargo, a veces es bueno diferenciar el caso donde el stream está vacío en lugar del caso donde hay un valor que coincide con la identidad que se devuelve del cálculo. La firma que devuelve un `Optional` nos permite diferenciar estos casos. Por ejemplo, podríamos devolver `Optional.empty()` cuando el stream está vacío y `Optional.of(3)` cuando hay un valor.

La tercera firma del método se utiliza cuando estamos tratando con diferentes tipos. Permite a Java crear reducciones intermedias y luego combinarlas al final. Veamos un ejemplo que cuenta el número de caracteres en cada String:

```java
Stream<String> stream = Stream.of("w", "o", "l", "f!");
int length = stream.reduce(0, (i, s) -> i+s.length(), (a, b) -> a+b);
System.out.println(length); // 5
```

El primer parámetro (0) es el valor para el inicializador. Si tuviéramos un stream vacío, esta sería la respuesta. El segundo parámetro es el acumulador. A diferencia de los acumuladores que viste anteriormente, este maneja tipos de datos mixtos. En este ejemplo, el primer argumento, i, es un Integer, mientras que el segundo argumento, s, es un String. Suma la longitud del String actual a nuestro total acumulado. El tercer parámetro se llama combiner, que combina cualquier total intermedio.

 En este caso, a y b son ambos valores Integer.

La operación de `reduce()` de tres argumentos es útil cuando se trabaja con streams paralelos porque permite que el stream se descomponga y se reensamble por hilos separados. Por ejemplo, si necesitáramos contar la longitud de cuatro strings de 100 caracteres, los dos primeros valores y los dos últimos valores podrían calcularse de manera independiente. El resultado intermedio (200 + 200) se combinaría luego en el valor final.


### collect()

El método `collect()` es un tipo especial de reducción llamada **reducción mutable**. Es más eficiente que una reducción regular porque usamos el mismo objeto mutable mientras acumulamos. Los objetos mutables comunes incluyen `StringBuilder` y `ArrayList`. Este es un método muy útil, porque nos permite obtener datos de los streams y convertirlos a otra forma. Las firmas del método son las siguientes:

```java
<R> R collect(Supplier<R> supplier, 
              BiConsumer<R, ? super T> accumulator, 
              BiConsumer<R, R> combiner)

<R, A> R collect(Collector<? super T, A, R> collector)
```

Comencemos con la primera firma, que se usa cuando queremos programar específicamente cómo debe funcionar la recolección. Nuestro ejemplo de "wolf" de `reduce` se puede convertir para usar `collect()`.

```java
Stream<String> stream = Stream.of("w", "o", "l", "f");
StringBuilder word = stream.collect(
    StringBuilder::new, 
    StringBuilder::append, 
    StringBuilder::append
);
System.out.println(word); // wolf
```

El primer parámetro es el **supplier**, que crea el objeto que almacenará los resultados mientras recolectamos datos. Recuerda que un `Supplier` no toma parámetros y devuelve un valor. En este caso, construye un nuevo `StringBuilder`.

El segundo parámetro es el **accumulator**, que es un `BiConsumer` que toma dos parámetros y no devuelve nada. Es responsable de agregar un elemento más a la colección de datos. En este ejemplo, agrega el siguiente `String` al `StringBuilder`.

El parámetro final es el **combiner**, que es otro `BiConsumer`. Es responsable de tomar dos colecciones de datos y fusionarlas. Esto es útil cuando estamos procesando en paralelo. Se forman dos colecciones más pequeñas y luego se fusionan en una. Esto funcionaría con `StringBuilder` solo si no nos importa el orden de las letras. En este caso, el acumulador y el combinador tienen una lógica similar.

Ahora veamos un ejemplo donde la lógica es diferente en el acumulador y el combinador.

```java
Stream<String> stream = Stream.of("w", "o", "l", "f");
TreeSet<String> set = stream.collect(
    TreeSet::new, 
    TreeSet::add, 
    TreeSet::addAll
);
System.out.println(set); // [f, l, o, w]
```

El colector tiene tres partes como antes. El **supplier** crea un `TreeSet` vacío. El **accumulator** agrega un solo `String` del `Stream` al `TreeSet`. El **combiner** agrega todos los elementos de un `TreeSet` a otro en caso de que las operaciones se hayan realizado en paralelo y necesiten ser fusionadas.

Comenzamos con la firma larga porque así es como implementas tu propio colector. Es importante saber cómo hacerlo para el examen y entender cómo funcionan los colectores. En la práctica, hay muchos colectores comunes que se repiten una y otra vez. En lugar de hacer que los desarrolladores vuelvan a implementar los mismos, Java proporciona una clase con colectores comunes llamada **Collectors**. Este enfoque también facilita la lectura del código porque es más expresivo. Por ejemplo, podríamos reescribir el ejemplo anterior de la siguiente manera:

```java
Stream<String> stream = Stream.of("w", "o", "l", "f");
TreeSet<String> set = 
    stream.collect(Collectors.toCollection(TreeSet::new));
System.out.println(set); // [f, l, o, w]
```

Si no necesitáramos que el conjunto esté ordenado, podríamos hacer el código aún más corto:

```java
Stream<String> stream = Stream.of("w", "o", "l", "f");
Set<String> set = stream.collect(Collectors.toSet());
System.out.println(set); // [f, w, l, o]
```

Es posible que obtengas una salida diferente para este último, ya que `toSet()` no garantiza qué implementación de `Set` obtendrás. Es probable que sea un `HashSet`, pero no deberías esperar ni confiar en eso.

> El examen espera que conozcas los colectores predefinidos comunes, además de ser capaz de escribir los tuyos propios pasando un proveedor, acumulador y combinador.

Más adelante en este capítulo, mostraremos muchos Collectors que se utilizan para agrupar datos. Es un tema amplio, por lo que es mejor dominar cómo funcionan los streams antes de agregar demasiados Collectors a la mezcla.

USANDO OPERACIONES INTERMEDIAS COMUNES

A diferencia de una operación terminal, una operación intermedia produce un *stream* como resultado. Una operación intermedia también puede manejar un *stream* infinito simplemente devolviendo otro *stream* infinito. Dado que los elementos se generan solo cuando se necesitan, esto funciona sin problemas. El trabajador de la línea de ensamblaje no necesita preocuparse por cuántos más elementos pasarán, sino que puede concentrarse en el elemento actual.

### filter()
El método `filter()` devuelve un `Stream` con los elementos que coinciden con una expresión dada. Esta es la firma del método:

```java
Stream<T> filter(Predicate<? super T> predicate)
```

Esta operación es fácil de recordar y poderosa porque podemos pasar cualquier `Predicate`. Por ejemplo, esto filtra todos los elementos que comienzan con la letra `m`:

```java
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
s.filter(x -> x.startsWith("m"))
 .forEach(System.out::print); // monkey
```

### distinct()
El método `distinct()` devuelve un *stream* con los valores duplicados eliminados. Los duplicados no tienen que ser adyacentes para ser removidos. Como podrías imaginar, Java llama a `equals()` para determinar si los objetos son iguales. La firma del método es la siguiente:

```java
Stream<T> distinct()
```

Aquí hay un ejemplo:

```java
Stream<String> s = Stream.of("duck", "duck", "duck", "goose");
s.distinct()
 .forEach(System.out::print); // duckgoose
```

### limit() y skip()
Los métodos `limit()` y `skip()` pueden hacer que un *stream* sea más pequeño o pueden convertir un *stream* infinito en uno finito. Las firmas de los métodos se muestran aquí:

```java
Stream<T> limit(long maxSize)
Stream<T> skip(long n)
```

El siguiente código crea un *stream* infinito de números que comienza en 1. La operación `skip()` devuelve un *stream* infinito que empieza con los números a partir del 6, ya que omite los primeros cinco elementos. La llamada a `limit()` toma los primeros dos de esos. Ahora tenemos un *stream* finito con dos elementos, que luego podemos imprimir con el método `forEach()`.

```java
Stream<Integer> s = Stream.iterate(1, n -> n + 1);
s.skip(5)
 .limit(2)
 .forEach(System.out::print); // 67
```

### map()
El método `map()` crea una asignación uno a uno desde los elementos del *stream* hasta los elementos del siguiente paso en el *stream*. La firma del método es la siguiente:

```java
<R> Stream<R> map(Function<? super T, ? extends R> mapper)
```

Esta parece más complicada que las demás que has visto. Utiliza la expresión *lambda* para determinar el tipo que se pasa a esa función y el que se devuelve. El tipo de retorno es el *stream* que se produce.

> **NOTA:** El método map() de los flujos se utiliza para transformar datos. No lo confunda con la interfaz Map, que asigna claves a valores.

Como ejemplo, este código convierte una lista de objetos `String` en una lista de objetos `Integer` que representan sus longitudes:

```java
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
s.map(String::length)
 .forEach(System.out::print); // 676
```

Recuerda que `String::length` es una forma abreviada de la lambda `x -> x.length()`, que muestra claramente que es una función que convierte un `String` en un `Integer`.

**flatMap()**  
El método `flatMap()` toma cada elemento del stream y hace que cualquier elemento que contenga se convierta en un elemento de nivel superior en un único stream. Esto es útil cuando quieres eliminar elementos vacíos de un stream o combinar un stream de listas. Te mostramos la firma del método para mantener la coherencia con los demás, solo para que no creas que ocultamos algo. No se espera que sepas leer esto:

```java
<R> Stream<R> flatMap(
    Function<? super T, ? extends Stream<? extends R>> mapper
)
```

Este galimatías básicamente dice que devuelve un `Stream` del tipo que contiene la función en un nivel inferior. No te preocupes por la firma. Es un dolor de cabeza.

Lo que debes entender es el ejemplo. Esto coloca a todos los animales en el mismo nivel, además de deshacerse de la lista vacía:

```java
List<String> zero = List.of();
var one = List.of("Bonobo");
var two = List.of("Mama Gorilla", "Baby Gorilla");
Stream<List<String>> animals = Stream.of(zero, one, two);
animals.flatMap(m -> m.stream())
       .forEach(System.out::println);
```

He aquí la salida:

```
Bonobo
Mama Gorilla
Baby Gorilla
```

Como puedes ver, eliminó la lista vacía por completo y cambió todos los elementos de cada lista para que estuvieran en el nivel superior del stream.

---

**sorted()**  
El método `sorted()` devuelve un stream con los elementos ordenados. Al igual que al ordenar arreglos, Java usa el orden natural a menos que especifiquemos un comparador. Las firmas de los métodos son estas:

```java
Stream<T> sorted()
Stream<T> sorted(Comparator<? super T> comparator)
```

Llamar a la primera firma utiliza el orden de clasificación predeterminado:

```java
Stream<String> s = Stream.of("brown-", "bear-");
s.sorted()
 .forEach(System.out::print); // bear-brown
```

Opcionalmente, podemos usar una implementación de `Comparator` a través de un método o una lambda. En este ejemplo, usamos un método:

```java
Stream<String> s = Stream.of("brown bear-", "grizzly-");
s.sorted(Comparator.reverseOrder())
 .forEach(System.out::print); // grizzly-brown bear-
```

Aquí pasamos un `Comparator` para especificar que queremos ordenar en el orden inverso al orden natural. ¿Listo para algo complicado? ¿Ves por qué esto no compila?

```java
s.sorted(Comparator::reverseOrder); // NO COMPILA
```

Observa las firmas de los métodos nuevamente. `Comparator` es una interfaz funcional. Esto significa que podemos usar referencias a métodos o lambdas para implementarla. La interfaz `Comparator` implementa un método que recibe dos parámetros `String` y devuelve un `int`. Sin embargo, `Comparator::reverseOrder` no hace eso. Es una referencia a una función que no recibe parámetros y devuelve un `Comparator`. Esto no es compatible con la interfaz. Significa que debemos usar un método (o expresión lambda) y no una referencia a método. Mencionamos esto para recordarte que realmente necesitas conocer bien las referencias a métodos.

---

**peek()**  
El método `peek()` es nuestra última operación intermedia. Es útil para depuración porque nos permite realizar una operación de stream sin cambiar realmente el stream. La firma del método es la siguiente:

```java
Stream<T> peek(Consumer<? super T> action)
```

Podrás notar que la operación intermedia `peek()` recibe el mismo argumento que la operación terminal `forEach()`. Piensa en `peek()` como una versión intermedia de `forEach()` que devuelve el stream original.

El uso más común de `peek()` es mostrar el contenido del stream conforme avanza. Supongamos que cometimos un error tipográfico y contamos osos que comienzan con la letra `g` en lugar de `b`. Nos preguntamos por qué el conteo es 1 en lugar de 2. Podemos añadir un `peek()` para averiguar por qué.

```java
var stream = Stream.of("black bear", "brown bear", "grizzly");
long count = stream.filter(s -> s.startsWith("g"))
                   .peek(System.out::println)  // grizzly
                   .count();
System.out.println(count); // 1
```

En el Capítulo 14, viste que `peek()` solo revisa el primer elemento al trabajar con una `Queue`. En un stream, `peek()` revisa cada elemento que pasa por esa parte de la tubería del stream. Es como tener un trabajador tomando notas sobre cómo va un paso particular del proceso.


**PELIGRO: CAMBIAR EL ESTADO CON `peek()`**

> Recuerda que `peek()` está pensado para realizar una operación sin alterar el resultado. Aquí tienes una canalización de _stream_ sencilla que no usa `peek()`:

```java
var numbers = new ArrayList<>();
var letters = new ArrayList<>();
numbers.add(1);
letters.add('a');
Stream<List<?>> stream = Stream.of(numbers, letters);
stream.map(List::size).forEach(System.out::print); // 11
```

> Ahora agregamos una llamada a `peek()` y notamos que Java no evita que escribamos un código inadecuado con `peek()`:

```java
Stream<List<?>> bad = Stream.of(numbers, letters);
bad.peek(x -> x.remove(0))
   .map(List::size)
   .forEach(System.out::print); // 00
```

> Este ejemplo es problemático porque `peek()` está modificando la estructura de datos que se usa en el _stream_, lo cual hace que el resultado de la canalización sea diferente a como sería si `peek()` no estuviera presente.
