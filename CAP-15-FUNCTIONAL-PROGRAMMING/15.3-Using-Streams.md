### USANDO STREAMS

Un **stream** en Java es una secuencia de datos. Una **tubería de stream** consiste en las operaciones que se ejecutan en un stream para producir un resultado. Primero, veremos el flujo de las tuberías conceptualmente. Después de eso, realmente nos adentraremos en el código.

### COMPRENDIENDO EL FLUJO DE LA TUBERÍA

Piensa en una tubería de stream como una línea de ensamblaje en una fábrica. Supongamos que estamos operando una línea de ensamblaje para hacer letreros para las exhibiciones de animales en el zoológico. Tenemos una serie de tareas. Es trabajo de una persona sacar letreros de una caja. Es trabajo de una segunda persona pintar el letrero. Es trabajo de una tercera persona estampar el nombre del animal en el letrero. Es trabajo de la última persona poner el letrero completado en una caja para ser llevado a la exhibición adecuada.

Observa que la segunda persona no puede hacer nada hasta que un letrero haya sido sacado de la caja por la primera persona. De manera similar, la tercera persona no puede hacer nada hasta que un letrero haya sido pintado, y la última persona no puede hacer nada hasta que esté estampar.

La línea de ensamblaje para hacer letreros es finita. Una vez que procesamos el contenido de nuestra caja de letreros, terminamos. Los **streams finitos** tienen un límite. Otras líneas de ensamblaje esencialmente corren para siempre, como una de producción de alimentos. Por supuesto, se detienen en algún momento cuando la fábrica cierra, pero finge que eso no sucede. O piensa en un ciclo de amanecer/atardecer como infinito, ya que no termina por un período de tiempo inusualmente largo.

Otra característica importante de una línea de ensamblaje es que cada persona toca cada elemento para realizar su operación y luego esa pieza de datos desaparece. No regresa. La siguiente persona la maneja en ese punto. Esto es diferente de las listas y colas que viste en el capítulo anterior. Con una lista, puedes acceder a cualquier elemento en cualquier momento. Con una cola, estás limitado en qué elementos puedes acceder, pero todos los elementos están allí. Con streams, los datos no se generan de antemano; se crean cuando se necesitan. Esto es un ejemplo de **evaluación perezosa (lazy evaluation)**, que retrasa la ejecución hasta que es necesario.

Muchas cosas pueden suceder en las estaciones de la línea de ensamblaje a lo largo del camino. En la programación funcional, esto se llama **operaciones de stream**. Al igual que con la línea de ensamblaje, las operaciones ocurren en una tubería. Alguien tiene que iniciar y terminar el trabajo, y puede haber cualquier número de estaciones en medio. Después de todo, ¡un trabajo con una sola persona no es una línea de ensamblaje! Hay tres partes en una tubería de stream, como se muestra en la **Figura 15.2**.

- **Fuente**: De dónde viene el stream.
- **Operaciones intermedias**: Transforma el stream en otro. Puede haber tan pocas o tantas operaciones intermedias como desees. Dado que los streams usan evaluación perezosa, las operaciones intermedias no se ejecutan hasta que la operación terminal se ejecuta.
- **Operación terminal**: Produce un resultado. Dado que los streams solo pueden usarse una vez, el stream ya no es válido después de que una operación terminal se completa.

### USANDO STREAMS

Un **stream** en Java es una secuencia de datos. Una **tubería de stream** consiste en las operaciones que se ejecutan en un stream para producir un resultado. Primero, veremos el flujo de las tuberías conceptualmente. Después de eso, realmente nos adentraremos en el código.

### COMPRENDIENDO EL FLUJO DE LA TUBERÍA

Piensa en una tubería de stream como una línea de ensamblaje en una fábrica. Supongamos que estamos operando una línea de ensamblaje para hacer letreros para las exhibiciones de animales en el zoológico. Tenemos una serie de tareas. Es trabajo de una persona sacar letreros de una caja. Es trabajo de una segunda persona pintar el letrero. Es trabajo de una tercera persona estampar el nombre del animal en el letrero. Es trabajo de la última persona poner el letrero completado en una caja para ser llevado a la exhibición adecuada.

Observa que la segunda persona no puede hacer nada hasta que un letrero haya sido sacado de la caja por la primera persona. De manera similar, la tercera persona no puede hacer nada hasta que un letrero haya sido pintado, y la última persona no puede hacer nada hasta que esté estampar.

La línea de ensamblaje para hacer letreros es finita. Una vez que procesamos el contenido de nuestra caja de letreros, terminamos. Los **streams finitos** tienen un límite. Otras líneas de ensamblaje esencialmente corren para siempre, como una de producción de alimentos. Por supuesto, se detienen en algún momento cuando la fábrica cierra, pero finge que eso no sucede. O piensa en un ciclo de amanecer/atardecer como infinito, ya que no termina por un período de tiempo inusualmente largo.

Otra característica importante de una línea de ensamblaje es que cada persona toca cada elemento para realizar su operación y luego esa pieza de datos desaparece. No regresa. La siguiente persona la maneja en ese punto. Esto es diferente de las listas y colas que viste en el capítulo anterior. Con una lista, puedes acceder a cualquier elemento en cualquier momento. Con una cola, estás limitado en qué elementos puedes acceder, pero todos los elementos están allí. Con streams, los datos no se generan de antemano; se crean cuando se necesitan. Esto es un ejemplo de **evaluación perezosa (lazy evaluation)**, que retrasa la ejecución hasta que es necesario.

Muchas cosas pueden suceder en las estaciones de la línea de ensamblaje a lo largo del camino. En la programación funcional, esto se llama **operaciones de stream**. Al igual que con la línea de ensamblaje, las operaciones ocurren en una tubería. Alguien tiene que iniciar y terminar el trabajo, y puede haber cualquier número de estaciones en medio. Después de todo, ¡un trabajo con una sola persona no es una línea de ensamblaje! Hay tres partes en una tubería de stream, como se muestra en la **Figura 15.2**.

#### TABLA 15.4 Operaciones intermedias vs. terminales

| Escenario                                      | Operación intermedia | Operación terminal |
|------------------------------------------------|----------------------|---------------------|
| ¿Parte requerida de una tubería útil?          | No                   | Sí                  |
| ¿Puede existir múltiples veces en una tubería? | Sí                   | No                  |
| ¿El tipo de retorno es un tipo de stream?      | Sí                   | No                  |
| ¿Se ejecuta al llamar el método?               | No                   | Sí                  |
| ¿El stream es válido después de la llamada?    | Sí                   | No                  |

Una fábrica típicamente tiene un capataz que supervisa el trabajo. Java actúa como el capataz al trabajar con tuberías de streams. Este es un rol realmente importante, especialmente al tratar con evaluación perezosa y streams infinitos. Piensa en declarar el stream como dar instrucciones al capataz. A medida que el capataz descubre lo que se necesita hacer, establece las estaciones y dice a los trabajadores cuáles serán sus tareas. Sin embargo, los trabajadores no comienzan hasta que el capataz les indica que inicien. El capataz espera hasta que ve la operación terminal para realmente iniciar el trabajo. También supervisa el trabajo y detiene la línea tan pronto como el trabajo está completo.

Veamos algunos ejemplos de esto. No estamos usando código en estos ejemplos porque es realmente importante entender el concepto de la tubería de streams antes de empezar a escribir el código. La **Figura 15.3** muestra una tubería de stream con una operación intermedia.

Primero, él ve que la fuente está sacando letreros de la caja. El capataz asigna a un trabajador en la mesa para desempacar la caja y le indica que espere una señal para comenzar. Luego, el capataz ve la operación intermedia para pintar el letrero. Asigna a un trabajador con pintura y le indica que espere una señal para comenzar. Finalmente, el capataz ve la operación terminal para poner los letreros en una pila. Asigna a un trabajador para hacer esto y grita que los tres trabajadores deben empezar.

Supongamos que hay dos letreros en la caja. El Paso 1 es que el primer trabajador saca un letrero de la caja y se lo entrega al segundo trabajador. El Paso 2 es que el segundo trabajador lo pinta y se lo entrega al tercer trabajador. El Paso 3 es que el tercer trabajador lo coloca en la pila. Los Pasos 4–6 son el mismo proceso para el otro letrero. Luego, el capataz ve que no quedan más letreros y cierra toda la operación.

El capataz es inteligente. Puede tomar decisiones sobre la mejor manera de realizar el trabajo según lo que se necesita. Como ejemplo, exploremos la tubería de stream en la **Figura 15.4**.

El capataz aún ve una fuente que saca letreros de la caja y asigna a un trabajador para que lo haga bajo comando. Aún ve una operación intermedia para pintar y asigna a otro trabajador con instrucciones para esperar y luego pintar. Luego, ve un paso intermedio en el que solo necesitamos dos letreros. Asigna a un trabajador para contar los letreros que pasan y le notifica cuando el trabajador ha visto dos. Finalmente, asigna a un trabajador para la operación terminal de poner los letreros en una pila.

Esta vez, supongamos que hay 10 letreros en la caja. Comenzamos como la última vez. El primer letrero avanza por la tubería. El segundo letrero también avanza por la tubería. Cuando la trabajadora encargada de contar ve el segundo letrero, le informa al capataz. El capataz permite que la trabajadora de la operación terminal termine su tarea y luego grita “detener la línea”. No importa que queden ocho letreros más en la caja. No los necesitamos, por lo que sería un trabajo innecesario pintarlos. ¡Y todos queremos evitar trabajos innecesarios!

De manera similar, el capataz habría detenido la línea después del primer letrero si la operación terminal hubiera sido encontrar el primer letrero que se crea.

### CREANDO FUENTES DE STREAMS

En Java, los streams de los que hemos estado hablando están representados por la interfaz `Stream<T>`, definida en el paquete `java.util.stream`.

#### Creando Streams Finitos

Para simplificar, comenzaremos con streams finitos. Hay varias maneras de crearlos.

```java
// Línea 11
Stream<String> empty = Stream.empty(); // count = 0

// Línea 12
Stream<Integer> singleElement = Stream.of(1); // count = 1

// Línea 13
Stream<Integer> fromArray = Stream.of(1, 2, 3); // count = 3
```

La línea 11 muestra cómo crear un stream vacío. La línea 12 muestra cómo crear un stream con un solo elemento. La línea 13 muestra cómo crear un stream a partir de un varargs. Sin duda has notado que en la línea 13 no hay un array. La firma del método usa varargs, lo que te permite especificar un array o elementos individuales.

Java también proporciona una manera conveniente de convertir una `Collection` en un stream.

```java
// Línea 14
var list = List.of("a", "b", "c");

// Línea 15
Stream<String> fromList = list.stream();
```

La línea 15 muestra que es una simple llamada de método para crear un stream a partir de una lista. Esto es útil ya que tales conversiones son comunes.

### CREANDO UN STREAM PARALELO

Es igual de fácil crear un stream paralelo a partir de una lista.

```java
// Línea 24
var list = List.of("a", "b", "c");

// Línea 25
Stream<String> fromListParallel = list.parallelStream();
```

Esta es una excelente característica porque puedes escribir código que utiliza concurrencia incluso antes de aprender qué es un hilo. Usar streams paralelos es como configurar múltiples mesas de trabajadores que pueden realizar la misma tarea. Pintar sería mucho más rápido si pudiéramos tener cinco pintores pintando letreros en lugar de solo uno. Solo ten en cuenta que algunas tareas no pueden hacerse en paralelo, como guardar los letreros en el orden en que fueron creados en el stream. Además, debes ser consciente de que hay un costo en la coordinación del trabajo, por lo que para streams más pequeños, podría ser más rápido hacerlo de manera secuencial. Aprenderás mucho más sobre cómo ejecutar tareas concurrentemente en el Capítulo 18.

### RESUMEN

- **Streams Paralelos**: Permiten procesar datos de manera concurrente, aprovechando múltiples hilos de ejecución para mejorar el rendimiento en tareas que pueden ser paralelizadas.
- **Creación de Streams Paralelos**: Se pueden crear fácilmente a partir de colecciones utilizando el método `parallelStream()`.
- **Consideraciones**:
  - **Tareas Adecuadas**: No todas las tareas son adecuadas para la paralelización. Tareas que dependen del orden o que no pueden ejecutarse simultáneamente deben evitarse.
  - **Costo de Coordinación**: La coordinación entre hilos puede introducir sobrecarga, por lo que para streams pequeños, puede ser más eficiente procesarlos de manera secuencial.
  - **Evaluación Perezosa**: Al igual que los streams secuenciales, los streams paralelos también utilizan evaluación perezosa, ejecutando las operaciones intermedias solo cuando se invoca una operación terminal.

### EJEMPLO ADICIONAL

Para ilustrar cómo crear y utilizar un stream paralelo, consideremos el siguiente ejemplo:

```java
import java.util.List;
import java.util.stream.Stream;

public class ParallelStreamExample {
    public static void main(String[] args) {
        var list = List.of("a", "b", "c", "d", "e", "f", "g", "h", "i", "j");
        Stream<String> fromListParallel = list.parallelStream();

        fromListParallel.forEach(elemento -> {
            System.out.println("Procesando: " + elemento + " en el hilo " + Thread.currentThread().getName());
        });
    }
}
```

#### Salida Esperada:
```
Procesando: a en el hilo ForkJoinPool.commonPool-worker-1
Procesando: b en el hilo ForkJoinPool.commonPool-worker-2
Procesando: c en el hilo ForkJoinPool.commonPool-worker-3
Procesando: d en el hilo ForkJoinPool.commonPool-worker-4
Procesando: e en el hilo ForkJoinPool.commonPool-worker-1
Procesando: f en el hilo ForkJoinPool.commonPool-worker-2
Procesando: g en el hilo ForkJoinPool.commonPool-worker-3
Procesando: h en el hilo ForkJoinPool.commonPool-worker-4
Procesando: i en el hilo ForkJoinPool.commonPool-worker-1
Procesando: j en el hilo ForkJoinPool.commonPool-worker-2
```

En este ejemplo:

1. **Creación del Stream Paralelo**: `list.parallelStream()` crea un stream paralelo a partir de la lista de elementos.
2. **Operación Terminal**: `.forEach(...)` procesa cada elemento del stream en paralelo, ejecutando la operación en diferentes hilos.
3. **Salida Concurrente**: La salida muestra que los elementos son procesados en diferentes hilos, lo que ilustra la concurrencia del stream paralelo.

### CONCLUSIÓN

Entender cómo crear y utilizar streams paralelos en Java te permite aprovechar mejor los recursos del sistema y mejorar el rendimiento de tus aplicaciones. Sin embargo, es importante evaluar cuidadosamente cuándo usar streams paralelos para evitar costos innecesarios de coordinación y asegurar que las tareas sean adecuadas para la paralelización.

Recuerda practicar estos conceptos y ejemplos para familiarizarte con el uso de streams paralelos en tus propios proyectos Java.

### CREANDO STREAMS INFINITOS

Hasta ahora, esto no es particularmente impresionante. Podríamos hacer todo esto con listas. Sin embargo, no podemos crear una lista infinita, lo que hace que los streams sean más poderosos.

```java
// Línea 17
Stream<Double> randoms = Stream.generate(Math::random); // Genera un stream de números aleatorios

// Línea 18
Stream<Integer> oddNumbers = Stream.iterate(1, n -> n + 2); // Genera un stream de números impares
```

La línea 17 genera un stream de números aleatorios. ¿Cuántos números aleatorios? La cantidad que necesites. Si llamas a `randoms.forEach(System.out::println)`, el programa imprimirá números aleatorios hasta que lo detengas. Más adelante en el capítulo, aprenderás sobre operaciones como `limit()` para convertir el stream infinito en un stream finito.

La línea 18 te da más control. El método `iterate()` toma una semilla o valor inicial como primer parámetro. Este es el primer elemento que formará parte del stream. El otro parámetro es una expresión lambda que recibe el valor anterior y genera el siguiente valor. Al igual que con el ejemplo de los números aleatorios, seguirá produciendo números impares mientras los necesites.

> Si intentas llamar a `System.out.print(stream)`, obtendrás algo como lo siguiente:

```java
java.util.stream.ReferencePipeline$3@4517d9a3
```

> Esto es diferente de una `Collection` donde ves el contenido. No necesitas saber esto para el examen. Lo mencionamos para que no te sorprenda al escribir código para practicar.
