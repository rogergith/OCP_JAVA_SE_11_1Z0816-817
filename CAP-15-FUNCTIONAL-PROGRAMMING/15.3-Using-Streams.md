### USANDO STREAMS

Un **stream** en Java es una secuencia de datos. Una **tubería de stream** consiste en las operaciones que se ejecutan en un stream para producir un resultado. Primero, veremos el flujo de las tuberías conceptualmente. Después de eso, realmente nos adentraremos en el código.

### COMPRENDIENDO EL FLUJO DE LA TUBERÍA

Piensa en una tubería de stream como una línea de ensamblaje en una fábrica. Supongamos que estamos operando una línea de ensamblaje para hacer letreros para las exhibiciones de animales en el zoológico. Tenemos una serie de tareas. Es trabajo de una persona sacar letreros de una caja. Es trabajo de una segunda persona pintar el letrero. Es trabajo de una tercera persona estampar el nombre del animal en el letrero. Es trabajo de la última persona poner el letrero completado en una caja para ser llevado a la exhibición adecuada.

Observa que la segunda persona no puede hacer nada hasta que un letrero haya sido sacado de la caja por la primera persona. De manera similar, la tercera persona no puede hacer nada hasta que un letrero haya sido pintado, y la última persona no puede hacer nada hasta que esté estampar.

La línea de ensamblaje para hacer letreros es finita. Una vez que procesamos el contenido de nuestra caja de letreros, terminamos. Los **streams finitos** tienen un límite. Otras líneas de ensamblaje esencialmente corren para siempre, como una de producción de alimentos. Por supuesto, se detienen en algún momento cuando la fábrica cierra, pero finge que eso no sucede. O piensa en un ciclo de amanecer/atardecer como infinito, ya que no termina por un período de tiempo inusualmente largo.

Otra característica importante de una línea de ensamblaje es que cada persona toca cada elemento para realizar su operación y luego esa pieza de datos desaparece. No regresa. La siguiente persona la maneja en ese punto. Esto es diferente de las listas y colas que viste en el capítulo anterior. Con una lista, puedes acceder a cualquier elemento en cualquier momento. Con una cola, estás limitado en qué elementos puedes acceder, pero todos los elementos están allí. Con streams, los datos no se generan de antemano; se crean cuando se necesitan. Esto es un ejemplo de **evaluación perezosa (lazy evaluation)**, que retrasa la ejecución hasta que es necesario.

Muchas cosas pueden suceder en las estaciones de la línea de ensamblaje a lo largo del camino. En la programación funcional, esto se llama **operaciones de stream**. Al igual que con la línea de ensamblaje, las operaciones ocurren en una tubería. Alguien tiene que iniciar y terminar el trabajo, y puede haber cualquier número de estaciones en medio. Después de todo, ¡un trabajo con una sola persona no es una línea de ensamblaje! Hay tres partes en una tubería de stream, como se muestra en la **Figura 15.2**.

- **Fuente**: De dónde viene el stream.
- **Operaciones intermedias**: Transforma el stream en otro. Puede haber tan pocas o tantas operaciones intermedias como desees. Dado que los streams usan evaluación perezosa, las operaciones intermedias no se ejecutan hasta que la operación terminal se ejecuta.
- **Operación terminal**: Produce un resultado. Dado que los streams solo pueden usarse una vez, el stream ya no es válido después de que una operación terminal se completa.

### USANDO STREAMS

Un **stream** en Java es una secuencia de datos. Una **tubería de stream** consiste en las operaciones que se ejecutan en un stream para producir un resultado. Primero, veremos el flujo de las tuberías conceptualmente. Después de eso, realmente nos adentraremos en el código.

### COMPRENDIENDO EL FLUJO DE LA TUBERÍA

Piensa en una tubería de stream como una línea de ensamblaje en una fábrica. Supongamos que estamos operando una línea de ensamblaje para hacer letreros para las exhibiciones de animales en el zoológico. Tenemos una serie de tareas. Es trabajo de una persona sacar letreros de una caja. Es trabajo de una segunda persona pintar el letrero. Es trabajo de una tercera persona estampar el nombre del animal en el letrero. Es trabajo de la última persona poner el letrero completado en una caja para ser llevado a la exhibición adecuada.

Observa que la segunda persona no puede hacer nada hasta que un letrero haya sido sacado de la caja por la primera persona. De manera similar, la tercera persona no puede hacer nada hasta que un letrero haya sido pintado, y la última persona no puede hacer nada hasta que esté estampar.

La línea de ensamblaje para hacer letreros es finita. Una vez que procesamos el contenido de nuestra caja de letreros, terminamos. Los **streams finitos** tienen un límite. Otras líneas de ensamblaje esencialmente corren para siempre, como una de producción de alimentos. Por supuesto, se detienen en algún momento cuando la fábrica cierra, pero finge que eso no sucede. O piensa en un ciclo de amanecer/atardecer como infinito, ya que no termina por un período de tiempo inusualmente largo.

Otra característica importante de una línea de ensamblaje es que cada persona toca cada elemento para realizar su operación y luego esa pieza de datos desaparece. No regresa. La siguiente persona la maneja en ese punto. Esto es diferente de las listas y colas que viste en el capítulo anterior. Con una lista, puedes acceder a cualquier elemento en cualquier momento. Con una cola, estás limitado en qué elementos puedes acceder, pero todos los elementos están allí. Con streams, los datos no se generan de antemano; se crean cuando se necesitan. Esto es un ejemplo de **evaluación perezosa (lazy evaluation)**, que retrasa la ejecución hasta que es necesario.

Muchas cosas pueden suceder en las estaciones de la línea de ensamblaje a lo largo del camino. En la programación funcional, esto se llama **operaciones de stream**. Al igual que con la línea de ensamblaje, las operaciones ocurren en una tubería. Alguien tiene que iniciar y terminar el trabajo, y puede haber cualquier número de estaciones en medio. Después de todo, ¡un trabajo con una sola persona no es una línea de ensamblaje! Hay tres partes en una tubería de stream, como se muestra en la **Figura 15.2**.

#### TABLA 15.4 Operaciones intermedias vs. terminales

| Escenario                                      | Operación intermedia | Operación terminal |
|------------------------------------------------|----------------------|---------------------|
| ¿Parte requerida de una tubería útil?          | No                   | Sí                  |
| ¿Puede existir múltiples veces en una tubería? | Sí                   | No                  |
| ¿El tipo de retorno es un tipo de stream?      | Sí                   | No                  |
| ¿Se ejecuta al llamar el método?               | No                   | Sí                  |
| ¿El stream es válido después de la llamada?    | Sí                   | No                  |

Una fábrica típicamente tiene un capataz que supervisa el trabajo. Java actúa como el capataz al trabajar con tuberías de streams. Este es un rol realmente importante, especialmente al tratar con evaluación perezosa y streams infinitos. Piensa en declarar el stream como dar instrucciones al capataz. A medida que el capataz descubre lo que se necesita hacer, establece las estaciones y dice a los trabajadores cuáles serán sus tareas. Sin embargo, los trabajadores no comienzan hasta que el capataz les indica que inicien. El capataz espera hasta que ve la operación terminal para realmente iniciar el trabajo. También supervisa el trabajo y detiene la línea tan pronto como el trabajo está completo.

Veamos algunos ejemplos de esto. No estamos usando código en estos ejemplos porque es realmente importante entender el concepto de la tubería de streams antes de empezar a escribir el código. La **Figura 15.3** muestra una tubería de stream con una operación intermedia.

Primero, él ve que la fuente está sacando letreros de la caja. El capataz asigna a un trabajador en la mesa para desempacar la caja y le indica que espere una señal para comenzar. Luego, el capataz ve la operación intermedia para pintar el letrero. Asigna a un trabajador con pintura y le indica que espere una señal para comenzar. Finalmente, el capataz ve la operación terminal para poner los letreros en una pila. Asigna a un trabajador para hacer esto y grita que los tres trabajadores deben empezar.

Supongamos que hay dos letreros en la caja. El Paso 1 es que el primer trabajador saca un letrero de la caja y se lo entrega al segundo trabajador. El Paso 2 es que el segundo trabajador lo pinta y se lo entrega al tercer trabajador. El Paso 3 es que el tercer trabajador lo coloca en la pila. Los Pasos 4–6 son el mismo proceso para el otro letrero. Luego, el capataz ve que no quedan más letreros y cierra toda la operación.

El capataz es inteligente. Puede tomar decisiones sobre la mejor manera de realizar el trabajo según lo que se necesita. Como ejemplo, exploremos la tubería de stream en la **Figura 15.4**.

El capataz aún ve una fuente que saca letreros de la caja y asigna a un trabajador para que lo haga bajo comando. Aún ve una operación intermedia para pintar y asigna a otro trabajador con instrucciones para esperar y luego pintar. Luego, ve un paso intermedio en el que solo necesitamos dos letreros. Asigna a un trabajador para contar los letreros que pasan y le notifica cuando el trabajador ha visto dos. Finalmente, asigna a un trabajador para la operación terminal de poner los letreros en una pila.

Esta vez, supongamos que hay 10 letreros en la caja. Comenzamos como la última vez. El primer letrero avanza por la tubería. El segundo letrero también avanza por la tubería. Cuando la trabajadora encargada de contar ve el segundo letrero, le informa al capataz. El capataz permite que la trabajadora de la operación terminal termine su tarea y luego grita “detener la línea”. No importa que queden ocho letreros más en la caja. No los necesitamos, por lo que sería un trabajo innecesario pintarlos. ¡Y todos queremos evitar trabajos innecesarios!

De manera similar, el capataz habría detenido la línea después del primer letrero si la operación terminal hubiera sido encontrar el primer letrero que se crea.

### CREANDO FUENTES DE STREAMS

En Java, los streams de los que hemos estado hablando están representados por la interfaz `Stream<T>`, definida en el paquete `java.util.stream`.

#### Creando Streams Finitos

Para simplificar, comenzaremos con streams finitos. Hay varias maneras de crearlos.

```java
// Línea 11
Stream<String> empty = Stream.empty(); // count = 0

// Línea 12
Stream<Integer> singleElement = Stream.of(1); // count = 1

// Línea 13
Stream<Integer> fromArray = Stream.of(1, 2, 3); // count = 3
```

La línea 11 muestra cómo crear un stream vacío. La línea 12 muestra cómo crear un stream con un solo elemento. La línea 13 muestra cómo crear un stream a partir de un varargs. Sin duda has notado que en la línea 13 no hay un array. La firma del método usa varargs, lo que te permite especificar un array o elementos individuales.

Java también proporciona una manera conveniente de convertir una `Collection` en un stream.

```java
// Línea 14
var list = List.of("a", "b", "c");

// Línea 15
Stream<String> fromList = list.stream();
```

La línea 15 muestra que es una simple llamada de método para crear un stream a partir de una lista. Esto es útil ya que tales conversiones son comunes.

### CREANDO UN STREAM PARALELO

Es igual de fácil crear un stream paralelo a partir de una lista.

```java
// Línea 24
var list = List.of("a", "b", "c");

// Línea 25
Stream<String> fromListParallel = list.parallelStream();
```

Esta es una excelente característica porque puedes escribir código que utiliza concurrencia incluso antes de aprender qué es un hilo. Usar streams paralelos es como configurar múltiples mesas de trabajadores que pueden realizar la misma tarea. Pintar sería mucho más rápido si pudiéramos tener cinco pintores pintando letreros en lugar de solo uno. Solo ten en cuenta que algunas tareas no pueden hacerse en paralelo, como guardar los letreros en el orden en que fueron creados en el stream. Además, debes ser consciente de que hay un costo en la coordinación del trabajo, por lo que para streams más pequeños, podría ser más rápido hacerlo de manera secuencial. Aprenderás mucho más sobre cómo ejecutar tareas concurrentemente en el Capítulo 18.

### RESUMEN

- **Streams Paralelos**: Permiten procesar datos de manera concurrente, aprovechando múltiples hilos de ejecución para mejorar el rendimiento en tareas que pueden ser paralelizadas.
- **Creación de Streams Paralelos**: Se pueden crear fácilmente a partir de colecciones utilizando el método `parallelStream()`.
- **Consideraciones**:
  - **Tareas Adecuadas**: No todas las tareas son adecuadas para la paralelización. Tareas que dependen del orden o que no pueden ejecutarse simultáneamente deben evitarse.
  - **Costo de Coordinación**: La coordinación entre hilos puede introducir sobrecarga, por lo que para streams pequeños, puede ser más eficiente procesarlos de manera secuencial.
  - **Evaluación Perezosa**: Al igual que los streams secuenciales, los streams paralelos también utilizan evaluación perezosa, ejecutando las operaciones intermedias solo cuando se invoca una operación terminal.

### EJEMPLO ADICIONAL

Para ilustrar cómo crear y utilizar un stream paralelo, consideremos el siguiente ejemplo:

```java
import java.util.List;
import java.util.stream.Stream;

public class ParallelStreamExample {
    public static void main(String[] args) {
        var list = List.of("a", "b", "c", "d", "e", "f", "g", "h", "i", "j");
        Stream<String> fromListParallel = list.parallelStream();

        fromListParallel.forEach(elemento -> {
            System.out.println("Procesando: " + elemento + " en el hilo " + Thread.currentThread().getName());
        });
    }
}
```

#### Salida Esperada:
```
Procesando: a en el hilo ForkJoinPool.commonPool-worker-1
Procesando: b en el hilo ForkJoinPool.commonPool-worker-2
Procesando: c en el hilo ForkJoinPool.commonPool-worker-3
Procesando: d en el hilo ForkJoinPool.commonPool-worker-4
Procesando: e en el hilo ForkJoinPool.commonPool-worker-1
Procesando: f en el hilo ForkJoinPool.commonPool-worker-2
Procesando: g en el hilo ForkJoinPool.commonPool-worker-3
Procesando: h en el hilo ForkJoinPool.commonPool-worker-4
Procesando: i en el hilo ForkJoinPool.commonPool-worker-1
Procesando: j en el hilo ForkJoinPool.commonPool-worker-2
```

En este ejemplo:

1. **Creación del Stream Paralelo**: `list.parallelStream()` crea un stream paralelo a partir de la lista de elementos.
2. **Operación Terminal**: `.forEach(...)` procesa cada elemento del stream en paralelo, ejecutando la operación en diferentes hilos.
3. **Salida Concurrente**: La salida muestra que los elementos son procesados en diferentes hilos, lo que ilustra la concurrencia del stream paralelo.

### CONCLUSIÓN

Entender cómo crear y utilizar streams paralelos en Java te permite aprovechar mejor los recursos del sistema y mejorar el rendimiento de tus aplicaciones. Sin embargo, es importante evaluar cuidadosamente cuándo usar streams paralelos para evitar costos innecesarios de coordinación y asegurar que las tareas sean adecuadas para la paralelización.

Recuerda practicar estos conceptos y ejemplos para familiarizarte con el uso de streams paralelos en tus propios proyectos Java.

### CREANDO STREAMS INFINITOS

Hasta ahora, esto no es particularmente impresionante. Podríamos hacer todo esto con listas. Sin embargo, no podemos crear una lista infinita, lo que hace que los streams sean más poderosos.

```java
// Línea 17
Stream<Double> randoms = Stream.generate(Math::random); // Genera un stream de números aleatorios

// Línea 18
Stream<Integer> oddNumbers = Stream.iterate(1, n -> n + 2); // Genera un stream de números impares
```

La línea 17 genera un stream de números aleatorios. ¿Cuántos números aleatorios? La cantidad que necesites. Si llamas a `randoms.forEach(System.out::println)`, el programa imprimirá números aleatorios hasta que lo detengas. Más adelante en el capítulo, aprenderás sobre operaciones como `limit()` para convertir el stream infinito en un stream finito.

La línea 18 te da más control. El método `iterate()` toma una semilla o valor inicial como primer parámetro. Este es el primer elemento que formará parte del stream. El otro parámetro es una expresión lambda que recibe el valor anterior y genera el siguiente valor. Al igual que con el ejemplo de los números aleatorios, seguirá produciendo números impares mientras los necesites.

> Si intentas llamar a `System.out.print(stream)`, obtendrás algo como lo siguiente:

```java
java.util.stream.ReferencePipeline$3@4517d9a3
```

> Esto es diferente de una `Collection` donde ves el contenido. No necesitas saber esto para el examen. Lo mencionamos para que no te sorprenda al escribir código para practicar.

¿Qué pasa si solo quieres números impares menores de 100? Java 9 introdujo una versión sobrecargada de `iterate()` que ayuda precisamente con eso.

```java
// Línea 19
Stream<Integer> oddNumberUnder100 = Stream.iterate(
    1, // semilla
    n -> n < 100, // Predicado para especificar cuándo terminar
    n -> n + 2 // UnaryOperator para obtener el siguiente valor
);
```

Este método toma tres parámetros. Observa cómo están separados por comas (,), al igual que todos los demás métodos. El examen podría intentar engañarte usando puntos y comas (`;`) ya que es similar a un bucle `for`. Similar a un bucle `for`, debes asegurarte de no estar creando accidentalmente un stream infinito.





### REVISIONANDO LOS MÉTODOS DE CREACIÓN DE STREAMS

Para repasar, asegúrate de conocer todos los métodos en la **Tabla 15.5**. Estas son las formas de crear una fuente para streams, dado una instancia de `Collection` llamada `coll`.

#### TABLA 15.5 Creando una fuente

| Método                               | ¿Finito o Infinito? | Notas                                                                                              |
|--------------------------------------|----------------------|----------------------------------------------------------------------------------------------------|
| `Stream.empty()`                     | Finito               | Crea un stream con cero elementos                                                                   |
| `Stream.of(varargs)`                 | Finito               | Crea un stream con los elementos listados                                                           |
| `coll.stream()`                      | Finito               | Crea un stream a partir de una colección                                                            |
| `coll.parallelStream()`              | Finito               | Crea un stream a partir de una colección donde el stream puede ejecutarse en paralelo               |
| `Stream.generate(supplier)`          | Infinito             | Crea un stream llamando al `Supplier` para cada elemento según se solicita                          |
| `Stream.iterate(seed, unaryOperator)`| Infinito             | Crea un stream usando la semilla para el primer elemento y luego llamando al `UnaryOperator` para cada elemento subsiguiente según se solicita |
| `Stream.iterate(seed, predicate, unaryOperator)` | Finito o Infinito | Crea un stream usando la semilla para el primer elemento y luego llamando al `UnaryOperator` para cada elemento subsiguiente según se solicita. Se detiene si el `Predicate` devuelve `false` |

#### Explicación de los Métodos

- **`Stream.empty()`**: Este método crea un stream vacío sin ningún elemento. Es útil cuando necesitas retornar un stream pero no tienes elementos que proporcionar.

    ```java
    Stream<String> empty = Stream.empty(); // count = 0
    ```

- **`Stream.of(varargs)`**: Crea un stream con los elementos proporcionados. Puedes pasar una lista de elementos separados por comas o un array.

    ```java
    Stream<Integer> singleElement = Stream.of(1); // count = 1
    Stream<Integer> fromArray = Stream.of(1, 2, 3); // count = 3
    ```

- **`coll.stream()`**: Convierte una colección en un stream. Es una forma sencilla y común de crear streams a partir de colecciones existentes.

    ```java
    var list = List.of("a", "b", "c");
    Stream<String> fromList = list.stream();
    ```

- **`coll.parallelStream()`**: Similar a `coll.stream()`, pero crea un stream que puede ejecutarse en paralelo, aprovechando múltiples hilos de ejecución para mejorar el rendimiento en operaciones que pueden ser paralelizadas.

    ```java
    var list = List.of("a", "b", "c");
    Stream<String> fromListParallel = list.parallelStream();
    ```

- **`Stream.generate(supplier)`**: Crea un stream infinito generando elementos mediante un `Supplier`. Cada vez que se solicita un elemento, se llama al `Supplier` para obtener el siguiente valor.

    ```java
    Stream<Double> randoms = Stream.generate(Math::random); // Genera un stream de números aleatorios
    ```

- **`Stream.iterate(seed, unaryOperator)`**: Crea un stream infinito comenzando con una semilla y aplicando un `UnaryOperator` para generar cada elemento subsiguiente.

    ```java
    Stream<Integer> oddNumbers = Stream.iterate(1, n -> n + 2); // Genera un stream de números impares
    ```

- **`Stream.iterate(seed, predicate, unaryOperator)`**: Introducido en Java 9, este método permite crear un stream finito o infinito utilizando una semilla, un `Predicate` para determinar cuándo detenerse y un `UnaryOperator` para generar los elementos.

    ```java
    Stream<Integer> oddNumberUnder100 = Stream.iterate(
        1, // semilla
        n -> n < 100, // Predicate para especificar cuándo terminar
        n -> n + 2  // UnaryOperator para obtener el siguiente valor
    );
    ```


### USANDO OPERACIONES TERMINALES COMUNES

Puedes realizar una operación terminal sin ninguna operación intermedia, pero no al revés. Por eso hablaremos de las operaciones terminales primero. Las reducciones son un tipo especial de operación terminal donde todo el contenido del stream se combina en un solo primitivo u objeto. Por ejemplo, podrías tener un `int` o una `Collection`.

La **Tabla 15.6** resume esta sección. Siéntete libre de usarla como guía para recordar los puntos más importantes mientras repasamos cada uno individualmente. Los explicamos de lo más simple a lo más complejo en lugar de alfabéticamente.

#### TABLA 15.6 Operaciones terminales de stream

| Método                               | Qué sucede para streams infinitos | Valor de retorno | Reducción |
|--------------------------------------|-----------------------------------|-------------------|-----------|
| `count()`                            | No termina                        | `long`            | Sí        |
| `min()` `max()`                      | No termina                        | `Optional<T>`     | Sí        |
| `findAny()` `findFirst()`            | Termina                           | `Optional<T>`     | No        |
| `allMatch()` `anyMatch()` `noneMatch()` | A veces termina                  | `boolean`         | No        |
| `forEach()`                          | No termina                        | `void`            | No        |
| `reduce()`                           | No termina                        | Varía             | Sí        |
| `collect()`                          | No termina                        | Varía             | Sí        |

### count()s

El método `count()` determina el número de elementos en un stream finito. Para un stream infinito, nunca termina. ¿Por qué? Cuenta desde 1 hasta el infinito y avísanos cuando termines. O mejor dicho, no hagas eso porque preferimos que estudies para el examen en lugar de pasar el resto de tu vida contando. El método `count()` es una reducción porque examina cada elemento en el stream y devuelve un solo valor. La firma del método es la siguiente:

```java
long count()
```

Este ejemplo muestra cómo llamar a `count()` en un stream finito:

```java
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
System.out.println(s.count()); // 3
```

### min() y max()

Los métodos `min()` y `max()` te permiten pasar un comparador personalizado y encontrar el valor más pequeño o más grande en un stream finito según ese orden de clasificación. Al igual que el método `count()`, `min()` y `max()` se quedan colgados en un stream infinito porque no pueden estar seguros de que un valor más pequeño o más grande no venga más adelante en el stream. Ambos métodos son reducciones porque devuelven un solo valor después de examinar todo el stream. Las firmas de los métodos son las siguientes:

```java
Optional<T> min(Comparator<? super T> comparator)
Optional<T> max(Comparator<? super T> comparator)
```

Este ejemplo encuentra el animal con menos letras en su nombre:

```java
Stream<String> s = Stream.of("monkey", "ape", "bonobo");
Optional<String> min = s.min((s1, s2) -> s1.length() - s2.length());
min.ifPresent(System.out::println); // ape
```

Observa que el código devuelve un `Optional` en lugar del valor. Esto permite que el método especifique que no se encontró un mínimo o máximo. Usamos el método `ifPresent()` de `Optional` y una referencia a un método para imprimir el mínimo solo si se encuentra uno. Como ejemplo de dónde no hay un mínimo, veamos un stream vacío.

```java
Optional<?> minEmpty = Stream.empty().min((s1, s2) -> 0);
System.out.println(minEmpty.isPresent()); // false
```

Dado que el stream está vacío, el comparador nunca se llama y no hay ningún valor presente en el `Optional`.

### RESUMEN

- **`min()` y `max()`**: Permiten encontrar el valor mínimo o máximo en un stream finito usando un comparador personalizado.
- **Retorno**: Devuelven un `Optional<T>` para manejar la posibilidad de que no se encuentre ningún valor.
- **Reducción**: Ambos métodos son operaciones de reducción ya que combinan todos los elementos del stream en un solo resultado.
- **Streams Infinitos**: En streams infinitos, `min()` y `max()` no terminan porque siempre puede haber un valor más pequeño o más grande.
- **Uso de `Optional`**: Permite manejar de manera segura la ausencia de un valor mínimo o máximo, evitando excepciones.

Recuerda practicar el uso de estos métodos y entender cómo funcionan con diferentes tipos de streams para prepararte adecuadamente para el examen.


### findAny() y findFirst()

Los métodos `findAny()` y `findFirst()` devuelven un elemento del stream a menos que el stream esté vacío. Si el stream está vacío, devuelven un `Optional` vacío. Este es el primer método que has visto que puede terminar con un stream infinito. Dado que Java genera solo la cantidad de stream que necesitas, el stream infinito solo necesita generar un elemento.

Como su nombre lo indica, el método `findAny()` puede devolver cualquier elemento del stream. Cuando se llama en los streams que has visto hasta ahora, comúnmente devuelve el primer elemento, aunque este comportamiento no está garantizado. Como verás en el Capítulo 18, el método `findAny()` es más probable que devuelva un elemento aleatorio cuando se trabaja con streams paralelos.

Estos métodos son operaciones terminales pero no reducciones. La razón es que a veces devuelven sin procesar todos los elementos. Esto significa que devuelven un valor basado en el stream pero no reducen todo el stream a un solo valor.

Las firmas de los métodos son las siguientes:
```java
Optional<T> findAny()
Optional<T> findFirst()
```

Este ejemplo encuentra un animal:
```java
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
Stream<String> infinite = Stream.generate(() -> "chimp");
s.findAny().ifPresent(System.out::println); // monkey (usualmente)
infinite.findAny().ifPresent(System.out::println); // chimp
```

Encontrar cualquier coincidencia es más útil de lo que parece. A veces solo queremos muestrear los resultados y obtener un elemento representativo, pero no necesitamos desperdiciar el procesamiento generándolos todos. Después de todo, si planeamos trabajar solo con un elemento, ¿por qué molestarse en mirar más?


> **NOTA:** ¿Qué pasa si necesitas tanto el valor mínimo como el máximo del mismo stream? Por ahora, no puedes tener ambos, al menos no utilizando estos métodos. Recuerda, un stream solo puede tener una operación terminal. Una vez que se ha ejecutado una operación terminal, el stream no puede ser utilizado nuevamente. Como veremos más adelante en este capítulo, hay métodos de resumen integrados para algunos streams numéricos que calcularán un conjunto de valores para ti.

### allMatch(), anyMatch() y noneMatch()

Los métodos `allMatch()`, `anyMatch()` y `noneMatch()` buscan en un stream y devuelven información sobre cómo el stream se relaciona con el predicado. Estos pueden o no terminar para streams infinitos. Depende de los datos. Al igual que los métodos de búsqueda, no son reducciones porque no necesariamente miran todos los elementos.

Las firmas de los métodos son las siguientes:
```java
boolean anyMatch(Predicate<? super T> predicate)
boolean allMatch(Predicate<? super T> predicate)
boolean noneMatch(Predicate<? super T> predicate)
```

Este ejemplo verifica si los nombres de animales comienzan con letras:
```java
var list = List.of("monkey", "2", "chimp");
Stream<String> infinite = Stream.generate(() -> "chimp");
Predicate<String> pred = x -> Character.isLetter(x.charAt(0));
System.out.println(list.stream().anyMatch(pred)); // true
System.out.println(list.stream().allMatch(pred)); // false
System.out.println(list.stream().noneMatch(pred)); // false
System.out.println(infinite.anyMatch(pred)); // true
```

Esto muestra que podemos reutilizar el mismo predicado, pero necesitamos un stream diferente cada vez. El método `anyMatch()` devuelve true porque dos de los tres elementos coinciden. El método `allMatch()` devuelve false porque uno no coincide. El método `noneMatch()` también devuelve false porque uno coincide. En el stream infinito, se encuentra una coincidencia, por lo que la llamada termina. Si llamáramos a `allMatch()`, correría hasta que matáramos el programa.
