**Trabajando con _Streams_ Primitivos**

Hasta ahora, todos los _streams_ que hemos creado han usado la clase `Stream` con un tipo genérico, como `Stream<String>`, `Stream<Integer>`, etc. Para valores numéricos, hemos estado utilizando las clases _wrapper_ que aprendiste en el capítulo 14. Hicimos esto con la API de _Collections_ para que te resultara natural.

En realidad, Java incluye otras clases de _streams_, además de `Stream`, que puedes usar para trabajar con tipos primitivos específicos: `int`, `double` y `long`. Veamos por qué esto es necesario. Supongamos que queremos calcular la suma de los números en un _stream_ finito:

```java
Stream<Integer> stream = Stream.of(1, 2, 3);
System.out.println(stream.reduce(0, (s, n) -> s + n)); // 6
```

No está mal. No fue difícil escribir una reducción. Iniciamos el acumulador en cero y, luego, sumamos cada número a ese total a medida que aparecía en el _stream_. Hay otra forma de hacer esto, como se ve aquí:

```java
Stream<Integer> stream = Stream.of(1, 2, 3);
System.out.println(stream.mapToInt(x -> x).sum()); // 6
```

Esta vez convertimos nuestro `Stream<Integer>` en un `IntStream` y le pedimos a `IntStream` que calcule la suma por nosotros. Un `IntStream` tiene muchos de los mismos métodos intermedios y terminales que un `Stream`, pero incluye métodos especializados para trabajar con datos numéricos. Los _streams_ primitivos saben cómo realizar ciertas operaciones comunes de forma automática.

Hasta ahora, esto parece una ventaja interesante, pero no muy trascendental. Ahora piensa en cómo calcularías un promedio. Necesitas dividir la suma entre el número de elementos. El problema es que los _streams_ permiten solo un paso. Java reconoce que calcular un promedio es una tarea común y, por ello, proporciona un método para calcular el promedio en las clases de _streams_ para primitivos:

```java
IntStream intStream = IntStream.of(1, 2, 3);
OptionalDouble avg = intStream.average();
System.out.println(avg.getAsDouble()); // 2.0
```

No solo es posible calcular el promedio, sino que también es muy fácil hacerlo. Está claro que los _streams_ primitivos son importantes. Veremos cómo crearlos y utilizarlos, incluyendo el uso de _optionals_ e interfaces funcionales.

### Creación de _Streams_ Primitivos

Existen tres tipos de _streams_ primitivos:

- `IntStream`: se utiliza para los tipos primitivos `int`, `short`, `byte` y `char`.
- `LongStream`: se utiliza para el tipo primitivo `long`.
- `DoubleStream`: se utiliza para los tipos primitivos `double` y `float`.

¿Por qué no tiene cada tipo primitivo su propio _stream_ primitivo? Estos tres son los más comunes, por lo que los diseñadores de la API optaron por ellos.

> **Cuando veas la palabra *stream* en el examen**, presta atención a las mayúsculas. Con “S” mayúscula o en el código, `Stream` es el nombre de una clase que contiene un tipo `Object`. Con “s” minúscula, un *stream* es un concepto que puede ser un `Stream`, `DoubleStream`, `IntStream` o `LongStream`.

La **Tabla 15.7** muestra algunos de los métodos que son exclusivos de los _streams_ primitivos. Observa que no incluimos en la tabla métodos como `empty()`, que ya conoces de la interfaz `Stream`.

---

**Tabla 15.7 Métodos comunes de _streams_ primitivos**

| Método                               | _Stream_ primitivo                 | Descripción                                                                                                       |
|--------------------------------------|-------------------------------------|-------------------------------------------------------------------------------------------------------------------|
| `OptionalDouble average()`           | `IntStream`<br>`LongStream`<br>`DoubleStream` | Calcula la media aritmética de los elementos                                                                     |
| `Stream<T> boxed()`                 | `IntStream`<br>`LongStream`<br>`DoubleStream` | Devuelve un `Stream<T>` donde `T` es la clase *wrapper* asociada con el valor primitivo                           |
| `OptionalInt max()`                 | `IntStream`                         | Devuelve el elemento máximo del _stream_                                                                          |
| `OptionalLong max()`                | `LongStream`                        | Lo mismo, para `LongStream`                                                                                      |
| `OptionalDouble max()`              | `DoubleStream`                      | Lo mismo, para `DoubleStream`                                                                                    |
| `OptionalInt min()`                 | `IntStream`                         | Devuelve el elemento mínimo del _stream_                                                                          |
| `OptionalLong min()`                | `LongStream`                        | Lo mismo, para `LongStream`                                                                                      |
| `OptionalDouble min()`              | `DoubleStream`                      | Lo mismo, para `DoubleStream`                                                                                    |
| `IntStream range(int a, int b)`     | `IntStream`                         | Devuelve un _stream_ primitivo desde `a` (incluido) hasta `b` (excluido)                                         |
| `LongStream range(long a, long b)`  | `LongStream`                        | Versión para `long`                                                                                              |
| `IntStream rangeClosed(int a, int b)` | `IntStream`                         | Devuelve un _stream_ primitivo desde `a` (incluido) hasta `b` (incluido)                                         |
| `LongStream rangeClosed(long a, long b)` | `LongStream`                    | Versión para `long`                                                                                              |
| `int sum()`                         | `IntStream`                         | Devuelve la suma de los elementos en el _stream_                                                                 |
| `long sum()`                        | `LongStream`                        | Versión para `LongStream`                                                                                       |
| `double sum()`                      | `DoubleStream`                      | Versión para `DoubleStream`                                                                                     |
| `IntSummaryStatistics summaryStatistics()` | `IntStream`               | Devuelve un objeto con múltiples estadísticas del _stream_ como promedio, mínimo, máximo, etc.                   |
| `LongSummaryStatistics summaryStatistics()` | `LongStream`            | Versión para `LongStream`                                                                                       |
| `DoubleSummaryStatistics summaryStatistics()` | `DoubleStream`        | Versión para `DoubleStream`                                                                                     |

---

Algunos de los métodos para crear un _stream_ primitivo son equivalentes a cómo creamos la fuente de un `Stream` normal. Puedes crear un _stream_ vacío así:

```java
DoubleStream empty = DoubleStream.empty();
```

Otra forma es usar el método de fábrica `of()` con un único valor o empleando la versión con *varargs*:

```java
DoubleStream oneValue = DoubleStream.of(3.14);
oneValue.forEach(System.out::println);

DoubleStream varargs = DoubleStream.of(1.0, 1.1, 1.2);
varargs.forEach(System.out::println);
```

Este código produce la siguiente salida:
```
3.14
1.0
1.1
1.2
```

También puedes utilizar dos métodos para crear _streams_ infinitos, tal como hicimos con `Stream`.

```java
var random = DoubleStream.generate(Math::random);
var fractions = DoubleStream.iterate(.5, d -> d / 2);
random.limit(3).forEach(System.out::println);
fractions.limit(3).forEach(System.out::println);
```

Como los _streams_ son infinitos, agregamos la operación intermedia `limit` para que la salida no imprima valores para siempre. El primer _stream_ llama a un método estático de `Math` para obtener un número aleatorio tipo `double`. Dado que los números son aleatorios, tu salida obviamente será diferente. El segundo _stream_ sigue generando números cada vez más pequeños, dividiendo el valor anterior entre dos en cada iteración. La salida que obtuvimos al ejecutar este código fue:

```
0.07890654781186413
0.28564363465842346
0.6311403511266134
0.5
0.25
0.125
```

No es necesario que sepas esto para el examen, pero la clase `Random` proporciona un método para obtener _streams_ primitivos de números aleatorios directamente. ¡Un dato curioso! Por ejemplo, `ints()` genera un `IntStream` infinito de primitivos.

Funciona de la misma manera para cada tipo de _stream_ primitivo. Cuando trabajamos con primitivos `int` o `long`, es común contar. Supongamos que queremos un _stream_ con los números del 1 al 5. Podríamos escribir:

```java
IntStream count = IntStream.iterate(1, n -> n + 1).limit(5);
count.forEach(System.out::println);
```

Este código sí imprime los números del 1 al 5, uno por línea. Sin embargo, es mucho código para algo tan sencillo. Java proporciona un método que puede generar un rango de números:

```java
IntStream range = IntStream.range(1, 6);
range.forEach(System.out::println);
```

Esto es mejor. Si queríamos los números del 1 al 5, ¿por qué pasamos del 1 al 6? El primer parámetro del método `range()` es inclusivo, lo que significa que incluye el número. El segundo parámetro es exclusivo, por lo que se detiene justo antes de ese número. Aun así, podría ser más claro. Queremos los números del 1 al 5 inclusivos. Por suerte, hay otro método, `rangeClosed()`, que es inclusivo para ambos parámetros:

```java
IntStream rangeClosed = IntStream.rangeClosed(1, 5);
rangeClosed.forEach(System.out::println);
```

Mucho mejor. Esta vez expresamos que queremos un rango cerrado, o un rango inclusivo. Este método se ajusta mejor a la forma en que expresamos un rango de números en lenguaje natural.


**MAPEO DE STREAMS**

Otra forma de crear un _stream_ primitivo es mediante el mapeo desde otro tipo de _stream_. La **Tabla 15.8** muestra que existe un método para mapear entre cualquier tipo de _stream_.

---

**Tabla 15.8 Métodos de mapeo entre tipos de _streams_**

| Clase de _stream_ de origen | Para crear `Stream`       | Para crear `DoubleStream`       | Para crear `IntStream`       | Para crear `LongStream`       |
|-----------------------------|---------------------------|---------------------------------|------------------------------|-------------------------------|
| `Stream<T>`                 | `map()`                  | `mapToDouble()`                 | `mapToInt()`                | `mapToLong()`                |
| `DoubleStream`              | `mapToObj()`             | `map()`                         | `mapToInt()`                | `mapToLong()`                |
| `IntStream`                 | `mapToObj()`             | `mapToDouble()`                 | `map()`                     | `mapToLong()`                |
| `LongStream`                | `mapToObj()`             | `mapToDouble()`                 | `mapToInt()`                | `map()`                      |

Obviamente, los tipos deben ser compatibles para que esto funcione. Java requiere que se proporcione una función de mapeo como parámetro. Por ejemplo:

```java
Stream<String> objStream = Stream.of("penguin", "fish");
IntStream intStream = objStream.mapToInt(s -> s.length());
```

Esta función recibe un `Object`, que en este caso es un `String`. La función devuelve un `int`. Las funciones de mapeo son intuitivas aquí: toman el tipo de origen y devuelven el tipo de destino. En este ejemplo, el tipo de la función real es `ToIntFunction`. La **Tabla 15.9** muestra los nombres de las funciones de mapeo. Como puedes ver, hacen lo que cabría esperar.

---

**Tabla 15.9 Parámetros de función al mapear entre tipos de _streams_**

| Clase de _stream_ de origen | Para crear `Stream` (`R`)      | Para crear `DoubleStream`               | Para crear `IntStream`                     | Para crear `LongStream`              |
|-----------------------------|---------------------------------|------------------------------------------|--------------------------------------------|--------------------------------------|
| `Stream<T>`                 | `Function<T,R>`                 | `ToDoubleFunction<T>`                    | `ToIntFunction<T>`                        | `ToLongFunction<T>`                  |
| `DoubleStream`              | `DoubleFunction<R>`             | `DoubleUnaryOperator`                    | `DoubleToIntFunction`                     | `DoubleToLongFunction`               |
| `IntStream`                 | `IntFunction<R>`                | `IntToDoubleFunction`                    | `IntUnaryOperator`                        | `IntToLongFunction`                  |
| `LongStream`                | `LongFunction<R>`               | `LongToDoubleFunction`                   | `LongToIntFunction`                       | `LongUnaryOperator`                  |

Sí necesitas memorizar la **Tabla 15.8** y la **Tabla 15.9**. No es tan complicado como podría parecer. Hay patrones en los nombres si recuerdas algunas reglas:

- Para la **Tabla 15.8**, cuando se mapea al mismo tipo con el que iniciaste, simplemente se llama `map()`. Cuando el resultado es un _stream_ de objetos, el método se llama `mapToObj()`. Más allá de eso, se usa el nombre del tipo primitivo en el nombre del método.
- Para la **Tabla 15.9**, puedes comenzar pensando en los tipos de origen y destino. Cuando el tipo de destino es un objeto, se omite el “To” del nombre. Cuando el mapeo es al mismo tipo con el que iniciaste, se utiliza un operador unario en lugar de una función para los _streams_ primitivos.


> **USANDO `flatMap()`**

> El método `flatMap()` también existe para _streams_ primitivos. Funciona de la misma manera que en un `Stream` regular, pero el nombre del método es diferente. Aquí tienes un ejemplo:

```java
var integerList = new ArrayList<Integer>();
IntStream ints = integerList.stream()
    .flatMapToInt(x -> IntStream.of(x));
DoubleStream doubles = integerList.stream()
    .flatMapToDouble(x -> DoubleStream.of(x));
LongStream longs = integerList.stream()
    .flatMapToLong(x -> LongStream.of(x));
```

Además, puedes crear un `Stream` a partir de un _stream_ primitivo. Estos métodos muestran dos maneras de lograrlo:

```java
private static Stream<Integer> mapping(IntStream stream) {
    return stream.mapToObj(x -> x);
}

private static Stream<Integer> boxing(IntStream stream) {
    return stream.boxed();
}
```

El primero utiliza el método `mapToObj()` que vimos antes. El segundo es más conciso. No requiere una función de mapeo porque lo único que hace es autoboxing de cada primitivo al objeto _wrapper_ correspondiente. El método `boxed()` existe en los tres tipos de _streams_ primitivos.

**USANDO `Optional` CON _STREAMS_ PRIMITIVOS**

Anteriormente en este capítulo, escribimos un método para calcular el promedio de un `int[]` y prometimos una manera mejor más adelante. Ahora que conoces los _streams_ primitivos, puedes calcular el promedio en una sola línea:

```java
var stream = IntStream.rangeClosed(1,10);
OptionalDouble optional = stream.average();
```

El tipo de retorno no es el `Optional` al que estás acostumbrado. Es un tipo nuevo llamado `OptionalDouble`. Quizá te preguntes por qué tenemos un tipo separado. ¿Por qué no usar simplemente `Optional<Double>`? La diferencia es que `OptionalDouble` está pensado para un primitivo, mientras que `Optional<Double>` está pensado para la clase envolvente (`Double`). Trabajar con la clase de _optional_ para primitivos es parecido a trabajar con la clase `Optional` en sí.

```java
optional.ifPresent(System.out::println); // 5.5
System.out.println(optional.getAsDouble()); // 5.5
System.out.println(optional.orElseGet(() -> Double.NaN)); // 5.5
```

La única diferencia notable es que llamamos a `getAsDouble()` en lugar de `get()`. Esto deja claro que estamos trabajando con un primitivo. Además, `orElseGet()` recibe un `DoubleSupplier` en vez de un `Supplier`.

Como ocurre con los _streams_ primitivos, existen tres clases de *optional* específicas para cada tipo primitivo. La **Tabla 15.10** muestra las pequeñas diferencias entre las tres. Probablemente no te sorprenderá saber que también debes memorizarla. Es muy fácil recordarla, pues el nombre del primitivo es el único cambio. Como recordarás de la sección de operaciones terminales, varios métodos de _stream_, como `min()` o `findAny()`, devuelven un _optional_. Cada uno retorna el tipo de _optional_ correspondiente. Las implementaciones de _stream_ para tipos primitivos también añaden dos métodos nuevos que necesitas conocer. El método `sum()` **no** devuelve un _optional_. Si intentas sumar un _stream_ vacío, simplemente obtienes cero. El método `average()` siempre devuelve un `OptionalDouble`, puesto que un promedio puede potencialmente tener parte fraccionaria en cualquier tipo.

---

**Tabla 15.10 Tipos de _optional_ para primitivos**

|                      | **OptionalDouble**  | **OptionalInt**     | **OptionalLong**    |
|----------------------|---------------------|---------------------|---------------------|
| **Obtención como primitivo** | `getAsDouble()`      | `getAsInt()`        | `getAsLong()`       |
| **Tipo del parámetro de `orElseGet()`** | `DoubleSupplier`     | `IntSupplier`       | `LongSupplier`      |
| **Tipo de retorno de `max()` y `min()`** | `OptionalDouble`     | `OptionalInt`       | `OptionalLong`      |
| **Tipo de retorno de `sum()`**           | `double`            | `int`              | `long`             |
| **Tipo de retorno de `average()`**       | `OptionalDouble`     | `OptionalDouble`    | `OptionalDouble`    |

---

Veamos un ejemplo para asegurarnos de que lo entiendes:

```java
5: LongStream longs = LongStream.of(5, 10);
6: long sum = longs.sum();
7: System.out.println(sum); // 15
8: DoubleStream doubles = DoubleStream.generate(() -> Math.PI);
9: OptionalDouble min = doubles.min(); // se ejecuta indefinidamente
```

En la línea 5 creamos un _stream_ de primitivos `long` con dos elementos. En la línea 6 vemos que no usamos un _optional_ para calcular la suma. En la línea 8 creamos un _stream_ infinito de primitivos `double`. La línea 9 está ahí para recordarte que también puede aparecer en el examen código que se ejecute indefinidamente con _streams_ primitivos.

---

### RESUMIENDO ESTADÍSTICAS

Ya has aprendido lo suficiente para obtener el valor máximo de un _stream_ de primitivos `int`. Si el _stream_ está vacío, queremos lanzar una excepción:

```java
private static int max(IntStream ints) {
    OptionalInt optional = ints.max();
    return optional.orElseThrow(RuntimeException::new);
}
```

Esto debería resultarte familiar a estas alturas. Obtenemos un `OptionalInt` porque tenemos un `IntStream`. Si el _optional_ contiene un valor, lo retornamos. De lo contrario, lanzamos una nueva `RuntimeException`.

Ahora queremos modificar el método para recibir un `IntStream` y devolver un rango. El rango se define como el valor mínimo restado al valor máximo. Problema: tanto `min()` como `max()` son operaciones terminales, lo que significa que consumen el _stream_ en cuanto se ejecutan. No podemos ejecutar dos operaciones terminales sobre el mismo _stream_. Por suerte, esto es un problema común, y los _streams_ primitivos lo resuelven con estadísticas resumidas (_summary statistics_). _Statistic_ es solo una palabra elegante para referirse a un número calculado a partir de datos.

```java
private static int range(IntStream ints) {
    IntSummaryStatistics stats = ints.summaryStatistics();
    if (stats.getCount() == 0) throw new RuntimeException();
    return stats.getMax() - stats.getMin();
}
```

Aquí le pedimos a Java que realice muchos cálculos sobre el _stream_. Las estadísticas resumidas incluyen lo siguiente:

- Número más pequeño (_mínimo_): `getMin()`
- Número más grande (_máximo_): `getMax()`
- Promedio: `getAverage()`
- Suma: `getSum()`
- Cantidad de valores: `getCount()`

Si el _stream_ estuviera vacío, tendríamos un recuento y una suma de cero. Los demás métodos devolverían un _optional_ vacío.

**APRENDIENDO LAS INTERFACES FUNCIONALES PARA PRIMITIVOS**  
¿Recuerdas cuando te dijimos que memorizaras la Tabla 15.1, con las interfaces funcionales comunes, al principio del capítulo? ¿Lo hiciste? Si no lo has hecho, hazlo ahora. Estamos a punto de complicarlo un poco más. Así como existen _streams_ y clases _optional_ específicas para tipos primitivos, también hay interfaces funcionales especiales para ellos.

Por suerte, la mayoría de ellas están asociadas con los tipos `double`, `int` y `long`, que ya viste para _streams_ y _optionals_. Hay una excepción: **`BooleanSupplier`**. Primero cubriremos esa antes de presentar las que corresponden a `double`, `int` y `long`.

### Interfaces funcionales para `boolean`

`BooleanSupplier` es un tipo independiente. Tiene un solo método que se debe implementar:
```java
boolean getAsBoolean()
```
Funciona igual que esperas de cualquier interfaz funcional. Aquí tienes un ejemplo:
```java
12: BooleanSupplier b1 = () -> true;
13: BooleanSupplier b2 = () -> Math.random() > .5;
14: System.out.println(b1.getAsBoolean());  // true
15: System.out.println(b2.getAsBoolean());  // puede ser true o false
```
En las líneas 12 y 13, se crea un `BooleanSupplier`, la única interfaz funcional para `boolean`.  
La línea 14 imprime `true`, ya que es el resultado de `b1`. La línea 15 imprime `true` o `false`, dependiendo del valor aleatorio generado.

### Interfaces funcionales para `double`, `int` y `long`

La mayoría de las interfaces funcionales se centran en `double`, `int` y `long`, en consonancia con los _streams_ y _optionals_ que hemos usado para tipos primitivos. La **Tabla 15.11** muestra el equivalente a la Tabla 15.1, pero para estos tipos. Seguramente no te sorprenda saber que debes memorizarla también. Por suerte, ya has memorizado la Tabla 15.1 y puedes aplicar lo aprendido a la Tabla 15.11.

---

#### Tabla 15.11 Interfaces funcionales comunes para tipos primitivos

| **Interfaces Funcionales**    | **# parámetros**                     | **Tipo de retorno**      | **Método abstracto único**     |
|---------------------------------|--------------------------------------|---------------------------|---------------------------------|
| **DoubleSupplier**<br>**IntSupplier**<br>**LongSupplier** | 0 (no reciben parámetros)            | `double`<br>`int`<br>`long`  | `getAsDouble()`<br>`getAsInt()`<br>`getAsLong()` |
| **DoubleConsumer**<br>**IntConsumer**<br>**LongConsumer** | 1 (`double`)<br>1 (`int`)<br>1 (`long`) | `void`                      | `accept()`                     |
| **DoublePredicate**<br>**IntPredicate**<br>**LongPredicate** | 1 (`double`)<br>1 (`int`)<br>1 (`long`) | `boolean`                  | `test()`                       |
| **DoubleFunction\<R\>**<br>**IntFunction\<R\>**<br>**LongFunction\<R\>** | 1 (`double`)<br>1 (`int`)<br>1 (`long`) | `R`                         | `apply()`                      |
| **DoubleUnaryOperator**<br>**IntUnaryOperator**<br>**LongUnaryOperator** | 1 (`double`)<br>1 (`int`)<br>1 (`long`) | `double`<br>`int`<br>`long` | `applyAsDouble()`<br>`applyAsInt()`<br>`applyAsLong()` |
| **DoubleBinaryOperator**<br>**IntBinaryOperator**<br>**LongBinaryOperator** | 2 (`double`, `double`)<br>2 (`int`, `int`)<br>2 (`long`, `long`) | `double`<br>`int`<br>`long` | `applyAsDouble()`<br>`applyAsInt()`<br>`applyAsLong()` |

---

Hay algunos detalles que notar, diferentes de la Tabla 15.1:

- Ya no hay genéricos en algunas interfaces; el nombre del tipo en la interfaz nos indica qué tipo primitivo se utiliza. En otros casos, como en `IntFunction`, solo se necesita el genérico del tipo de retorno, porque estamos convirtiendo un `int` primitivo en un objeto.
- El método abstracto único suele renombrarse cuando el tipo de retorno es primitivo.

Además de los equivalentes de la Tabla 15.1, existen algunas interfaces específicas para los primitivos. La **Tabla 15.12** las enumera.

---

#### Tabla 15.12 Interfaces funcionales específicas para primitivos

| **Interfaces Funcionales**                                | **# parámetros** | **Tipo de retorno** | **Método abstracto único** |
|-------------------------------------------------------------|-------------------|----------------------|----------------------------|
| **ToDoubleFunction\<T\>**<br>**ToIntFunction\<T\>**<br>**ToLongFunction\<T\>** | 1 (`T`)           | `double`<br>`int`<br>`long` | `applyAsDouble()`<br>`applyAsInt()`<br>`applyAsLong()` |
| **ToDoubleBiFunction\<T, U\>**<br>**ToIntBiFunction\<T, U\>**<br>**ToLongBiFunction\<T, U\>** | 2 (`T`, `U`)      | `double`<br>`int`<br>`long` | `applyAsDouble()`<br>`applyAsInt()`<br>`applyAsLong()` |
| **DoubleToIntFunction**<br>**DoubleToLongFunction**<br>**IntToDoubleFunction**<br>**IntToLongFunction**<br>**LongToDoubleFunction**<br>**LongToIntFunction** | 1 (`double`)<br>1 (`double`)<br>1 (`int`)<br>1 (`int`)<br>1 (`long`)<br>1 (`long`) | `int`<br>`long`<br>`double`<br>`long`<br>`double`<br>`int` | `applyAsInt()`<br>`applyAsLong()`<br>`applyAsDouble()`<br>`applyAsLong()`<br>`applyAsDouble()`<br>`applyAsInt()` |
| **ObjDoubleConsumer\<T\>**<br>**ObjIntConsumer\<T\>**<br>**ObjLongConsumer\<T\>** | 2 (`T`, `double`)<br>2 (`T`, `int`)<br>2 (`T`, `long`) | `void` | `accept()` |

---

Hemos estado usando interfaces funcionales durante todo el capítulo, así que a estas alturas ya deberías tener buena práctica en leer tablas como esta. Hagamos un ejemplo para confirmarlo:

```java
var d = 1.0;
______________ f1 = x -> 1;
f1.applyAsInt(d);
```
Cuando veas una pregunta como esta, busca pistas:

- Sabes que la interfaz funcional toma un parámetro `double` y devuelve un `int`.
- También sabes que el método abstracto se llama `applyAsInt`.

Tanto `DoubleToIntFunction` como `ToIntFunction<T>` cumplen esos tres requisitos.

---

## Trabajando con conceptos avanzados de canalización _stream_

Casi has terminado de aprender sobre _streams_. Solo quedan algunos temas más. Verás la relación entre los _streams_ y los datos subyacentes, el encadenamiento de `Optional` y los recolectores por agrupación.

### VINCULANDO LOS _STREAMS_ CON LOS DATOS SUBYACENTES

¿Qué crees que imprime este código?
```java
25: var cats = new ArrayList<String>();
26: cats.add("Annie");
27: cats.add("Ripley");
28: var stream = cats.stream();
29: cats.add("KC");
30: System.out.println(stream.count());
```
La respuesta correcta es `3`. Las líneas 25–27 crean una `List` con dos elementos. La línea 28 solicita la creación de un _stream_ a partir de esa `List`. Recuerda que los _streams_ se evalúan de forma *perezosa* (*lazy evaluation*). Esto significa que el _stream_ no se evalúa realmente en la línea 28. Se crea un objeto que sabe dónde buscar los datos cuando sea necesario. En la línea 29, agregamos un nuevo elemento a la `List`. Y en la línea 30, la canalización del _stream_ se ejecuta de verdad. En ese momento, el _stream_ ve la fuente y encuentra tres elementos.

### ENCADENANDO _OPTIONALS_

A estas alturas, estás familiarizado con las ventajas de encadenar operaciones en una canalización de _stream_. Algunas de las operaciones intermedias para _streams_ también están disponibles para `Optional`.

Supongamos que recibes un `Optional<Integer>` y te piden imprimir el valor, pero solo si tiene tres dígitos. Sin programación funcional, podrías escribir lo siguiente:

```java
private static void threeDigit(Optional<Integer> optional) {
    if (optional.isPresent()) { // if externo
        var num = optional.get();
        var string = "" + num;
        if (string.length() == 3) // if interno
            System.out.println(string);
    }
}
```
Funciona, pero contiene sentencias `if` anidadas, agregando complejidad extra.  
Reescribámoslo con programación funcional:

```java
private static void threeDigit(Optional<Integer> optional) {
    optional.map(n -> "" + n)            // parte 1
            .filter(s -> s.length() == 3) // parte 2
            .ifPresent(System.out::println); // parte 3
}
```
Es mucho más breve y expresivo. En los exámenes, es frecuente que se divida una sola sentencia con comentarios para identificar sus partes. Hemos hecho eso aquí para mostrar lo que sucede tanto en la versión funcional como en la no funcional.

- Si recibimos un `Optional.empty()`, la primera aproximación retorna `false` en el `if` externo. La segunda ve un `Optional` vacío y, tanto `map()` como `filter()` lo dejan pasar tal cual; luego `ifPresent()` ve un `Optional` vacío y no llama al `Consumer`.
- Si recibimos un `Optional.of(4)`, la primera aproximación retorna `false` en el `if` interno. La segunda convierte el número `4` en `"4"` mediante `map()`. Luego, `filter()` devuelve un `Optional` vacío (porque la longitud no coincide), por lo que `ifPresent()` no llama al `Consumer`.
- Si recibimos un `Optional.of(123)`, la primera aproximación retorna `true` en ambos `if`. La segunda convierte el número `123` en `"123"`. El `filter()` deja pasar este valor (la longitud coincide), y `ifPresent()` finalmente llama al `Consumer`.

Ahora supongamos que queremos obtener un `Optional<Integer>` que represente la longitud de la `String` contenida en otro `Optional`. Eso es sencillo:
```java
Optional<Integer> result = optional.map(String::length);
```
¿Y si tenemos un método auxiliar que haga la lógica de calcular algo y retorne `Optional<Integer>`? Si usamos `map`, no funciona:
```java
Optional<Integer> result = optional
    .map(ChainingOptionals::calculator); // NO COMPILA
```
El problema es que `calculator` devuelve `Optional<Integer>`. El método `map()` añadiría otro `Optional`, resultando en `Optional<Optional<Integer>>`. Eso no sirve. La solución es llamar a `flatMap()`:
```java
Optional<Integer> result = optional
    .flatMap(ChainingOptionals::calculator);
```
Esto sí funciona porque `flatMap` elimina esa capa innecesaria. En otras palabras, *aplana* el resultado. Encadenar llamadas a `flatMap()` es útil cuando quieres transformar un tipo de `Optional` en otro.

**EXCEPCIONES VERIFICADAS Y LAS INTERFACES FUNCIONALES**  
Es posible que hayas notado a estas alturas que la mayoría de las interfaces funcionales no declaran excepciones verificadas (*checked exceptions*). Normalmente, esto no representa un problema. Sin embargo, sí lo es cuando trabajamos con métodos que declaran excepciones verificadas. Supongamos que tenemos una clase con un método que lanza una excepción verificada:

```java
import java.io.*;
import java.util.*;

public class ExceptionCaseStudy {
    private static List<String> create() throws IOException {
        throw new IOException();
    }
}
```

Ahora lo usamos en un _stream_:

```java
public void good() throws IOException {
    ExceptionCaseStudy.create().stream().count();
}
```

No hay nada nuevo aquí. El método `create()` lanza una excepción verificada. El método que llama a `create()` maneja o declara esa excepción. ¿Y ahora qué sucede con este otro ejemplo?

```java
public void bad() throws IOException {
    Supplier<List<String>> s = ExceptionCaseStudy::create; // NO COMPILA
}
```

El error real del compilador es el siguiente:
```
unhandled exception type IOException
```

¿Y esto qué significa? El problema es que la expresión lambda a la que se expande esta referencia de método no declara la excepción. La interfaz `Supplier` no permite excepciones verificadas. Hay dos maneras de sortear este problema. Una es capturar la excepción y convertirla en una excepción no verificada (*unchecked exception*).

```java
public void ugly() {
    Supplier<List<String>> s = () -> {
        try {
            return ExceptionCaseStudy.create();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    };
}
```

Esto funciona. Pero el código es feo. Una de las ventajas de la programación funcional es que el código debería ser fácil de leer y conciso. Otra alternativa es crear un método *wrapper* con el bloque `try/catch`:

```java
private static List<String> createSafe() {
    try {
        return ExceptionCaseStudy.create();
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
```

Ahora podemos usar el _wrapper_ seguro en nuestro `Supplier` sin problema:

```java
public void wrapped() {
    Supplier<List<String>> s2 = ExceptionCaseStudy::createSafe;
}
```

---

## RECOPILANDO RESULTADOS

Casi has terminado de aprender sobre _streams_. El último tema se basa en lo que has aprendido hasta ahora para agrupar resultados. Al principio del capítulo, viste la operación terminal `collect()`. Existen muchos **_collectors_** predefinidos, incluidos los que se muestran en la **Tabla 15.13**. Estos _collectors_ están disponibles a través de métodos estáticos en la interfaz `Collectors`. Veremos los diferentes tipos de _collectors_ en las siguientes secciones.

---

**Tabla 15.13 Ejemplos de _collectors_ para agrupación/partición**

| **Collector**                                                    | **Descripción**                                                                                                                   | **Valor de retorno al pasar a `collect`**                                  |
|------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------|
| `averagingDouble(ToDoubleFunction f)`<br>`averagingInt(ToIntFunction f)`<br>`averagingLong(ToLongFunction f)` | Calcula el promedio para nuestros tres tipos primitivos principales                                                              | `Double`                                                                   |
| `counting()`                                                     | Cuenta el número de elementos                                                                                                     | `Long`                                                                     |
| `groupingBy(Function f)`<br>`groupingBy(Function f, Collector dc)`<br>`groupingBy(Function f, Supplier s, Collector dc)` | Crea un mapa agrupando según la función especificada, con un *map type supplier* opcional y un *downstream collector* opcional | `Map<K, List<T>>`                                                         |
| `joining(CharSequence cs)`                                       | Crea un solo `String` usando `cs` como delimitador entre elementos (si se especifica)                                            | `String`                                                                   |
| `maxBy(Comparator c)`<br>`minBy(Comparator c)`                   | Encuentra los elementos más grandes/pequeños                                                                                     | `Optional<T>`                                                              |
| `mapping(Function f, Collector dc)`                              | Agrega otro nivel de _collectors_                                                                                                 | `Collector`                                                                |
| `partitioningBy(Predicate p)`<br>`partitioningBy(Predicate p, Collector dc)` | Crea un mapa que agrupa según la expresión booleana, con un _downstream collector_ opcional                                      | `Map<Boolean, List<T>>`                                                    |
| `summarizingDouble(ToDoubleFunction f)`<br>`summarizingInt(ToIntFunction f)`<br>`summarizingLong(ToLongFunction f)` | Calcula el promedio, el mínimo, el máximo, etc.                                                                                  | `DoubleSummaryStatistics`<br>`IntSummaryStatistics`<br>`LongSummaryStatistics` |
| `summingDouble(ToDoubleFunction f)`<br>`summingInt(ToIntFunction f)`<br>`summingLong(ToLongFunction f)` | Calcula la suma para nuestros tres tipos primitivos principales                                                                  | `Double`<br>`Integer`<br>`Long`                                            |
| `toList()` / `toSet()`                                          | Crea un tipo arbitrario de lista o conjunto                                                                                      | `List` / `Set`                                                             |
| `toCollection(Supplier s)`                                       | Crea una `Collection` del tipo especificado                                                                                      | `Collection`                                                               |
| `toMap(Function k, Function v)`<br>`toMap(Function k, Function v, BinaryOperator m)`<br>`toMap(Function k, Function v, BinaryOperator m, Supplier s)` | Crea un mapa usando funciones para mapear las llaves, los valores, una posible función de fusión (*merge function*) y un *map type supplier* opcional | `Map`                                                                      |

---

### Recolección usando _collectors_ básicos

Por suerte, muchos de estos _collectors_ funcionan de la misma manera. Veamos un ejemplo:

```java
var ohMy = Stream.of("lions", "tigers", "bears");
String result = ohMy.collect(Collectors.joining(", "));
System.out.println(result); // lions, tigers, bears
```

Observa que los _collectors_ predefinidos están en la clase `Collectors` en lugar de la interfaz `Collector`. Esta es una práctica común, como la que viste con `Collection` versus `Collections`. De hecho, verás este patrón otra vez en el Capítulo 20, “NIO.2”, al trabajar con `Paths` y `Path`, y con otros tipos relacionados.

Le pasamos el _collector_ predefinido `joining()` al método `collect()`. Todos los elementos del _stream_ se fusionan entonces en un `String` con el delimitador especificado entre cada elemento. Es importante pasar el `Collector` al método `collect`, ya que existe para ayudar en la recolección de elementos. Un `Collector` no hace nada por sí mismo.

Probemos otro. ¿Cuál es la longitud promedio de los nombres de estos tres animales?

```java
var ohMy = Stream.of("lions", "tigers", "bears");
Double result = ohMy.collect(Collectors.averagingInt(String::length));
System.out.println(result); // 5.333333333333333
```

La lógica es la misma. Le pasamos un _collector_ a `collect()`, y este calcula el promedio por nosotros. Esta vez, teníamos que pasar una función para indicar al _collector_ qué promediar. Usamos una referencia a método (`String::length`), que retorna un `int` al ejecutarse. Con _streams_ primitivos, el resultado de un promedio siempre era un `double`, sin importar el tipo promediado. Para los _collectors_, el resultado es un `Double` porque necesita un objeto.

A menudo, tendrás que interactuar con código que se escribió sin _streams_. Esto significa que esperará un tipo `Collection` en lugar de un _stream_. Sin problema. Aun así, puedes expresarte con un _stream_ y luego convertirlo en una `Collection` al final, por ejemplo:

```java
var ohMy = Stream.of("lions", "tigers", "bears");
TreeSet<String> result = ohMy
    .filter(s -> s.startsWith("t"))
    .collect(Collectors.toCollection(TreeSet::new));
System.out.println(result); // [tigers]
```

Esta vez, tenemos las tres partes de la canalización del _stream_. `Stream.of()` es la fuente. La operación intermedia es `filter()`. Por último, la operación terminal es `collect()`, que crea un `TreeSet`. Si no nos importara la implementación de `Set`, podríamos haber usado `Collectors.toSet()`.

A estas alturas, ya deberías ser capaz de usar todos los _collectors_ de la **Tabla 15.13** excepto `groupingBy()`, `mapping()`, `partitioningBy()` y `toMap()`.

---

### Recolectando en mapas

El código que usa `Collectors` para trabajar con mapas puede ser bastante extenso. Iremos construyendo los ejemplos poco a poco. Asegúrate de entender cada uno antes de pasar al siguiente. Empecemos con un ejemplo sencillo para crear un mapa a partir de un _stream_:

```java
var ohMy = Stream.of("lions", "tigers", "bears");
Map<String, Integer> map = ohMy.collect(
    Collectors.toMap(s -> s, String::length)
);
System.out.println(map); // {lions=5, bears=5, tigers=6}
```

Cuando creas un mapa, necesitas especificar dos funciones. La primera le indica al _collector_ cómo crear la **clave**. En nuestro ejemplo, usamos la propia `String` como clave. La segunda función le indica al _collector_ cómo crear el **valor**. En nuestro ejemplo, usamos la longitud de la `String` como valor.

> Devolver el mismo valor que se pasa a una lambda es una operación común, por lo que Java proporciona un método para ello. Puedes reescribir `s -> s` como `Function.identity()`. No es más corto y puede o no ser más claro, así que usa tu criterio para decidir si utilizarlo.


Ahora queremos hacer lo contrario y mapear la longitud del nombre del animal a su propio nombre. Nuestro primer intento incorrecto se muestra aquí:

```java
var ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, String> map = ohMy.collect(Collectors.toMap(
    String::length,
    k -> k)); // MAL
```

Al ejecutar esto, se produce una excepción similar a la siguiente:

```
Exception in thread "main"
java.lang.IllegalStateException: Duplicate key 5
```

¿Qué sucede? Dos de los nombres de animales tienen la misma longitud. No le indicamos a Java qué debía hacer. ¿El *collector* debería elegir el primer valor que encuentra? ¿El último? ¿Concatenarlos? Dado que el *collector* no tiene idea de qué hacer, “resuelve” el problema lanzando una excepción y dejando que sea tu problema. ¡Qué considerado!

Supongamos ahora que nuestro requisito es crear un `String` separado por comas con los nombres de los animales. Podríamos escribir:

```java
var ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, String> map = ohMy.collect(Collectors.toMap(
    String::length,
    k -> k,
    (s1, s2) -> s1 + "," + s2
));
System.out.println(map); // {5=lions,bears, 6=tigers}
System.out.println(map.getClass()); // class java.util.HashMap
```

Resulta que el `Map` que se devuelve es un `HashMap`. Este comportamiento **no** está garantizado. Supongamos que queremos exigir que el código devuelva un `TreeMap` en su lugar. No hay problema. Solo añadimos una referencia al constructor como parámetro:

```java
var ohMy = Stream.of("lions", "tigers", "bears");
TreeMap<Integer, String> map = ohMy.collect(Collectors.toMap(
    String::length,
    k -> k,
    (s1, s2) -> s1 + "," + s2,
    TreeMap::new
));
System.out.println(map); // {5=lions,bears, 6=tigers}
System.out.println(map.getClass()); // class java.util.TreeMap
```

Esta vez obtuvimos el tipo que especificamos. ¿Nos sigues hasta aquí? El código es largo, pero no demasiado complicado. ¡Te prometimos que sería largo!

---

### Recolección usando *Grouping*, *Partitioning* y *Mapping*

Buen trabajo llegando hasta aquí. A los creadores del examen les gusta hacer preguntas sobre `groupingBy()` y `partitioningBy()`, así que asegúrate de entender muy bien estas secciones. Ahora supongamos que queremos agrupar los nombres según su longitud. Podemos hacerlo indicando que queremos agrupar por longitud:

```java
var ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, List<String>> map = ohMy.collect(
    Collectors.groupingBy(String::length)
);
System.out.println(map); // {5=[lions, bears], 6=[tigers]}
```

El *collector* `groupingBy()` le dice a `collect()` que agrupe todos los elementos del *stream* en un `Map`. La función determina las claves en el `Map`. Cada valor en el `Map` es una `List` de todos los elementos que coinciden con esa clave.

> Note que la función que llamas en `groupingBy()` no puede devolver `null`. No permite claves `null`.
