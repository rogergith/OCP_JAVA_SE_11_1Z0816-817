**Trabajando con _Streams_ Primitivos**

Hasta ahora, todos los _streams_ que hemos creado han usado la clase `Stream` con un tipo genérico, como `Stream<String>`, `Stream<Integer>`, etc. Para valores numéricos, hemos estado utilizando las clases _wrapper_ que aprendiste en el capítulo 14. Hicimos esto con la API de _Collections_ para que te resultara natural.

En realidad, Java incluye otras clases de _streams_, además de `Stream`, que puedes usar para trabajar con tipos primitivos específicos: `int`, `double` y `long`. Veamos por qué esto es necesario. Supongamos que queremos calcular la suma de los números en un _stream_ finito:

```java
Stream<Integer> stream = Stream.of(1, 2, 3);
System.out.println(stream.reduce(0, (s, n) -> s + n)); // 6
```

No está mal. No fue difícil escribir una reducción. Iniciamos el acumulador en cero y, luego, sumamos cada número a ese total a medida que aparecía en el _stream_. Hay otra forma de hacer esto, como se ve aquí:

```java
Stream<Integer> stream = Stream.of(1, 2, 3);
System.out.println(stream.mapToInt(x -> x).sum()); // 6
```

Esta vez convertimos nuestro `Stream<Integer>` en un `IntStream` y le pedimos a `IntStream` que calcule la suma por nosotros. Un `IntStream` tiene muchos de los mismos métodos intermedios y terminales que un `Stream`, pero incluye métodos especializados para trabajar con datos numéricos. Los _streams_ primitivos saben cómo realizar ciertas operaciones comunes de forma automática.

Hasta ahora, esto parece una ventaja interesante, pero no muy trascendental. Ahora piensa en cómo calcularías un promedio. Necesitas dividir la suma entre el número de elementos. El problema es que los _streams_ permiten solo un paso. Java reconoce que calcular un promedio es una tarea común y, por ello, proporciona un método para calcular el promedio en las clases de _streams_ para primitivos:

```java
IntStream intStream = IntStream.of(1, 2, 3);
OptionalDouble avg = intStream.average();
System.out.println(avg.getAsDouble()); // 2.0
```

No solo es posible calcular el promedio, sino que también es muy fácil hacerlo. Está claro que los _streams_ primitivos son importantes. Veremos cómo crearlos y utilizarlos, incluyendo el uso de _optionals_ e interfaces funcionales.

### Creación de _Streams_ Primitivos

Existen tres tipos de _streams_ primitivos:

- `IntStream`: se utiliza para los tipos primitivos `int`, `short`, `byte` y `char`.
- `LongStream`: se utiliza para el tipo primitivo `long`.
- `DoubleStream`: se utiliza para los tipos primitivos `double` y `float`.

¿Por qué no tiene cada tipo primitivo su propio _stream_ primitivo? Estos tres son los más comunes, por lo que los diseñadores de la API optaron por ellos.

> **Cuando veas la palabra *stream* en el examen**, presta atención a las mayúsculas. Con “S” mayúscula o en el código, `Stream` es el nombre de una clase que contiene un tipo `Object`. Con “s” minúscula, un *stream* es un concepto que puede ser un `Stream`, `DoubleStream`, `IntStream` o `LongStream`.

La **Tabla 15.7** muestra algunos de los métodos que son exclusivos de los _streams_ primitivos. Observa que no incluimos en la tabla métodos como `empty()`, que ya conoces de la interfaz `Stream`.

---

**Tabla 15.7 Métodos comunes de _streams_ primitivos**

| Método                               | _Stream_ primitivo                 | Descripción                                                                                                       |
|--------------------------------------|-------------------------------------|-------------------------------------------------------------------------------------------------------------------|
| `OptionalDouble average()`           | `IntStream`<br>`LongStream`<br>`DoubleStream` | Calcula la media aritmética de los elementos                                                                     |
| `Stream<T> boxed()`                 | `IntStream`<br>`LongStream`<br>`DoubleStream` | Devuelve un `Stream<T>` donde `T` es la clase *wrapper* asociada con el valor primitivo                           |
| `OptionalInt max()`                 | `IntStream`                         | Devuelve el elemento máximo del _stream_                                                                          |
| `OptionalLong max()`                | `LongStream`                        | Lo mismo, para `LongStream`                                                                                      |
| `OptionalDouble max()`              | `DoubleStream`                      | Lo mismo, para `DoubleStream`                                                                                    |
| `OptionalInt min()`                 | `IntStream`                         | Devuelve el elemento mínimo del _stream_                                                                          |
| `OptionalLong min()`                | `LongStream`                        | Lo mismo, para `LongStream`                                                                                      |
| `OptionalDouble min()`              | `DoubleStream`                      | Lo mismo, para `DoubleStream`                                                                                    |
| `IntStream range(int a, int b)`     | `IntStream`                         | Devuelve un _stream_ primitivo desde `a` (incluido) hasta `b` (excluido)                                         |
| `LongStream range(long a, long b)`  | `LongStream`                        | Versión para `long`                                                                                              |
| `IntStream rangeClosed(int a, int b)` | `IntStream`                         | Devuelve un _stream_ primitivo desde `a` (incluido) hasta `b` (incluido)                                         |
| `LongStream rangeClosed(long a, long b)` | `LongStream`                    | Versión para `long`                                                                                              |
| `int sum()`                         | `IntStream`                         | Devuelve la suma de los elementos en el _stream_                                                                 |
| `long sum()`                        | `LongStream`                        | Versión para `LongStream`                                                                                       |
| `double sum()`                      | `DoubleStream`                      | Versión para `DoubleStream`                                                                                     |
| `IntSummaryStatistics summaryStatistics()` | `IntStream`               | Devuelve un objeto con múltiples estadísticas del _stream_ como promedio, mínimo, máximo, etc.                   |
| `LongSummaryStatistics summaryStatistics()` | `LongStream`            | Versión para `LongStream`                                                                                       |
| `DoubleSummaryStatistics summaryStatistics()` | `DoubleStream`        | Versión para `DoubleStream`                                                                                     |

---

Algunos de los métodos para crear un _stream_ primitivo son equivalentes a cómo creamos la fuente de un `Stream` normal. Puedes crear un _stream_ vacío así:

```java
DoubleStream empty = DoubleStream.empty();
```

Otra forma es usar el método de fábrica `of()` con un único valor o empleando la versión con *varargs*:

```java
DoubleStream oneValue = DoubleStream.of(3.14);
oneValue.forEach(System.out::println);

DoubleStream varargs = DoubleStream.of(1.0, 1.1, 1.2);
varargs.forEach(System.out::println);
```

Este código produce la siguiente salida:
```
3.14
1.0
1.1
1.2
```

También puedes utilizar dos métodos para crear _streams_ infinitos, tal como hicimos con `Stream`.

```java
var random = DoubleStream.generate(Math::random);
var fractions = DoubleStream.iterate(.5, d -> d / 2);
random.limit(3).forEach(System.out::println);
fractions.limit(3).forEach(System.out::println);
```

Como los _streams_ son infinitos, agregamos la operación intermedia `limit` para que la salida no imprima valores para siempre. El primer _stream_ llama a un método estático de `Math` para obtener un número aleatorio tipo `double`. Dado que los números son aleatorios, tu salida obviamente será diferente. El segundo _stream_ sigue generando números cada vez más pequeños, dividiendo el valor anterior entre dos en cada iteración. La salida que obtuvimos al ejecutar este código fue:

```
0.07890654781186413
0.28564363465842346
0.6311403511266134
0.5
0.25
0.125
```

No es necesario que sepas esto para el examen, pero la clase `Random` proporciona un método para obtener _streams_ primitivos de números aleatorios directamente. ¡Un dato curioso! Por ejemplo, `ints()` genera un `IntStream` infinito de primitivos.

Funciona de la misma manera para cada tipo de _stream_ primitivo. Cuando trabajamos con primitivos `int` o `long`, es común contar. Supongamos que queremos un _stream_ con los números del 1 al 5. Podríamos escribir:

```java
IntStream count = IntStream.iterate(1, n -> n + 1).limit(5);
count.forEach(System.out::println);
```

Este código sí imprime los números del 1 al 5, uno por línea. Sin embargo, es mucho código para algo tan sencillo. Java proporciona un método que puede generar un rango de números:

```java
IntStream range = IntStream.range(1, 6);
range.forEach(System.out::println);
```

Esto es mejor. Si queríamos los números del 1 al 5, ¿por qué pasamos del 1 al 6? El primer parámetro del método `range()` es inclusivo, lo que significa que incluye el número. El segundo parámetro es exclusivo, por lo que se detiene justo antes de ese número. Aun así, podría ser más claro. Queremos los números del 1 al 5 inclusivos. Por suerte, hay otro método, `rangeClosed()`, que es inclusivo para ambos parámetros:

```java
IntStream rangeClosed = IntStream.rangeClosed(1, 5);
rangeClosed.forEach(System.out::println);
```

Mucho mejor. Esta vez expresamos que queremos un rango cerrado, o un rango inclusivo. Este método se ajusta mejor a la forma en que expresamos un rango de números en lenguaje natural.


**MAPEO DE STREAMS**

Otra forma de crear un _stream_ primitivo es mediante el mapeo desde otro tipo de _stream_. La **Tabla 15.8** muestra que existe un método para mapear entre cualquier tipo de _stream_.

---

**Tabla 15.8 Métodos de mapeo entre tipos de _streams_**

| Clase de _stream_ de origen | Para crear `Stream`       | Para crear `DoubleStream`       | Para crear `IntStream`       | Para crear `LongStream`       |
|-----------------------------|---------------------------|---------------------------------|------------------------------|-------------------------------|
| `Stream<T>`                 | `map()`                  | `mapToDouble()`                 | `mapToInt()`                | `mapToLong()`                |
| `DoubleStream`              | `mapToObj()`             | `map()`                         | `mapToInt()`                | `mapToLong()`                |
| `IntStream`                 | `mapToObj()`             | `mapToDouble()`                 | `map()`                     | `mapToLong()`                |
| `LongStream`                | `mapToObj()`             | `mapToDouble()`                 | `mapToInt()`                | `map()`                      |

Obviamente, los tipos deben ser compatibles para que esto funcione. Java requiere que se proporcione una función de mapeo como parámetro. Por ejemplo:

```java
Stream<String> objStream = Stream.of("penguin", "fish");
IntStream intStream = objStream.mapToInt(s -> s.length());
```

Esta función recibe un `Object`, que en este caso es un `String`. La función devuelve un `int`. Las funciones de mapeo son intuitivas aquí: toman el tipo de origen y devuelven el tipo de destino. En este ejemplo, el tipo de la función real es `ToIntFunction`. La **Tabla 15.9** muestra los nombres de las funciones de mapeo. Como puedes ver, hacen lo que cabría esperar.

---

**Tabla 15.9 Parámetros de función al mapear entre tipos de _streams_**

| Clase de _stream_ de origen | Para crear `Stream` (`R`)      | Para crear `DoubleStream`               | Para crear `IntStream`                     | Para crear `LongStream`              |
|-----------------------------|---------------------------------|------------------------------------------|--------------------------------------------|--------------------------------------|
| `Stream<T>`                 | `Function<T,R>`                 | `ToDoubleFunction<T>`                    | `ToIntFunction<T>`                        | `ToLongFunction<T>`                  |
| `DoubleStream`              | `DoubleFunction<R>`             | `DoubleUnaryOperator`                    | `DoubleToIntFunction`                     | `DoubleToLongFunction`               |
| `IntStream`                 | `IntFunction<R>`                | `IntToDoubleFunction`                    | `IntUnaryOperator`                        | `IntToLongFunction`                  |
| `LongStream`                | `LongFunction<R>`               | `LongToDoubleFunction`                   | `LongToIntFunction`                       | `LongUnaryOperator`                  |

Sí necesitas memorizar la **Tabla 15.8** y la **Tabla 15.9**. No es tan complicado como podría parecer. Hay patrones en los nombres si recuerdas algunas reglas:

- Para la **Tabla 15.8**, cuando se mapea al mismo tipo con el que iniciaste, simplemente se llama `map()`. Cuando el resultado es un _stream_ de objetos, el método se llama `mapToObj()`. Más allá de eso, se usa el nombre del tipo primitivo en el nombre del método.
- Para la **Tabla 15.9**, puedes comenzar pensando en los tipos de origen y destino. Cuando el tipo de destino es un objeto, se omite el “To” del nombre. Cuando el mapeo es al mismo tipo con el que iniciaste, se utiliza un operador unario en lugar de una función para los _streams_ primitivos.


> **USANDO `flatMap()`**

> El método `flatMap()` también existe para _streams_ primitivos. Funciona de la misma manera que en un `Stream` regular, pero el nombre del método es diferente. Aquí tienes un ejemplo:

```java
var integerList = new ArrayList<Integer>();
IntStream ints = integerList.stream()
    .flatMapToInt(x -> IntStream.of(x));
DoubleStream doubles = integerList.stream()
    .flatMapToDouble(x -> DoubleStream.of(x));
LongStream longs = integerList.stream()
    .flatMapToLong(x -> LongStream.of(x));
```

Además, puedes crear un `Stream` a partir de un _stream_ primitivo. Estos métodos muestran dos maneras de lograrlo:

```java
private static Stream<Integer> mapping(IntStream stream) {
    return stream.mapToObj(x -> x);
}

private static Stream<Integer> boxing(IntStream stream) {
    return stream.boxed();
}
```

El primero utiliza el método `mapToObj()` que vimos antes. El segundo es más conciso. No requiere una función de mapeo porque lo único que hace es autoboxing de cada primitivo al objeto _wrapper_ correspondiente. El método `boxed()` existe en los tres tipos de _streams_ primitivos.

**USANDO `Optional` CON _STREAMS_ PRIMITIVOS**

Anteriormente en este capítulo, escribimos un método para calcular el promedio de un `int[]` y prometimos una manera mejor más adelante. Ahora que conoces los _streams_ primitivos, puedes calcular el promedio en una sola línea:

```java
var stream = IntStream.rangeClosed(1,10);
OptionalDouble optional = stream.average();
```

El tipo de retorno no es el `Optional` al que estás acostumbrado. Es un tipo nuevo llamado `OptionalDouble`. Quizá te preguntes por qué tenemos un tipo separado. ¿Por qué no usar simplemente `Optional<Double>`? La diferencia es que `OptionalDouble` está pensado para un primitivo, mientras que `Optional<Double>` está pensado para la clase envolvente (`Double`). Trabajar con la clase de _optional_ para primitivos es parecido a trabajar con la clase `Optional` en sí.

```java
optional.ifPresent(System.out::println); // 5.5
System.out.println(optional.getAsDouble()); // 5.5
System.out.println(optional.orElseGet(() -> Double.NaN)); // 5.5
```

La única diferencia notable es que llamamos a `getAsDouble()` en lugar de `get()`. Esto deja claro que estamos trabajando con un primitivo. Además, `orElseGet()` recibe un `DoubleSupplier` en vez de un `Supplier`.

Como ocurre con los _streams_ primitivos, existen tres clases de *optional* específicas para cada tipo primitivo. La **Tabla 15.10** muestra las pequeñas diferencias entre las tres. Probablemente no te sorprenderá saber que también debes memorizarla. Es muy fácil recordarla, pues el nombre del primitivo es el único cambio. Como recordarás de la sección de operaciones terminales, varios métodos de _stream_, como `min()` o `findAny()`, devuelven un _optional_. Cada uno retorna el tipo de _optional_ correspondiente. Las implementaciones de _stream_ para tipos primitivos también añaden dos métodos nuevos que necesitas conocer. El método `sum()` **no** devuelve un _optional_. Si intentas sumar un _stream_ vacío, simplemente obtienes cero. El método `average()` siempre devuelve un `OptionalDouble`, puesto que un promedio puede potencialmente tener parte fraccionaria en cualquier tipo.

---

**Tabla 15.10 Tipos de _optional_ para primitivos**

|                      | **OptionalDouble**  | **OptionalInt**     | **OptionalLong**    |
|----------------------|---------------------|---------------------|---------------------|
| **Obtención como primitivo** | `getAsDouble()`      | `getAsInt()`        | `getAsLong()`       |
| **Tipo del parámetro de `orElseGet()`** | `DoubleSupplier`     | `IntSupplier`       | `LongSupplier`      |
| **Tipo de retorno de `max()` y `min()`** | `OptionalDouble`     | `OptionalInt`       | `OptionalLong`      |
| **Tipo de retorno de `sum()`**           | `double`            | `int`              | `long`             |
| **Tipo de retorno de `average()`**       | `OptionalDouble`     | `OptionalDouble`    | `OptionalDouble`    |

---

Veamos un ejemplo para asegurarnos de que lo entiendes:

```java
5: LongStream longs = LongStream.of(5, 10);
6: long sum = longs.sum();
7: System.out.println(sum); // 15
8: DoubleStream doubles = DoubleStream.generate(() -> Math.PI);
9: OptionalDouble min = doubles.min(); // se ejecuta indefinidamente
```

En la línea 5 creamos un _stream_ de primitivos `long` con dos elementos. En la línea 6 vemos que no usamos un _optional_ para calcular la suma. En la línea 8 creamos un _stream_ infinito de primitivos `double`. La línea 9 está ahí para recordarte que también puede aparecer en el examen código que se ejecute indefinidamente con _streams_ primitivos.

---

### RESUMIENDO ESTADÍSTICAS

Ya has aprendido lo suficiente para obtener el valor máximo de un _stream_ de primitivos `int`. Si el _stream_ está vacío, queremos lanzar una excepción:

```java
private static int max(IntStream ints) {
    OptionalInt optional = ints.max();
    return optional.orElseThrow(RuntimeException::new);
}
```

Esto debería resultarte familiar a estas alturas. Obtenemos un `OptionalInt` porque tenemos un `IntStream`. Si el _optional_ contiene un valor, lo retornamos. De lo contrario, lanzamos una nueva `RuntimeException`.

Ahora queremos modificar el método para recibir un `IntStream` y devolver un rango. El rango se define como el valor mínimo restado al valor máximo. Problema: tanto `min()` como `max()` son operaciones terminales, lo que significa que consumen el _stream_ en cuanto se ejecutan. No podemos ejecutar dos operaciones terminales sobre el mismo _stream_. Por suerte, esto es un problema común, y los _streams_ primitivos lo resuelven con estadísticas resumidas (_summary statistics_). _Statistic_ es solo una palabra elegante para referirse a un número calculado a partir de datos.

```java
private static int range(IntStream ints) {
    IntSummaryStatistics stats = ints.summaryStatistics();
    if (stats.getCount() == 0) throw new RuntimeException();
    return stats.getMax() - stats.getMin();
}
```

Aquí le pedimos a Java que realice muchos cálculos sobre el _stream_. Las estadísticas resumidas incluyen lo siguiente:

- Número más pequeño (_mínimo_): `getMin()`
- Número más grande (_máximo_): `getMax()`
- Promedio: `getAverage()`
- Suma: `getSum()`
- Cantidad de valores: `getCount()`

Si el _stream_ estuviera vacío, tendríamos un recuento y una suma de cero. Los demás métodos devolverían un _optional_ vacío.
